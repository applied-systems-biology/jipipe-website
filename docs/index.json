[
{
	"uri": "https://applied-systems-biology.github.io/jipipe/_header/",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "by Applied Systems Biology, HKI Jena, Germany\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/graph-node/",
	"title": "Algorithm node",
	"tags": [],
	"description": "Node in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm-node.schema.json\n Node in a graph   jipipe:slot-configuration:  object   [object Object]      User-defined slots. Might be ignored depending on the algorithm. The keys are the slot names. See slot-definition        jipipe:algorithm-ui-location:  object   [object Object]     Locations of this node within the UI. Optional. The keys depend on the UI implementation. See point        jipipe:algorithm-type:  string       Algorithm type ID   jipipe:algorithm-compartment:  string   DEFAULT      Compartment ID. Only important for the UI.   name:  string       A custom name for this algorithm. Only important for the UI. If null or empty, the UI will default to the algorithm type name.   description:  object       A custom description. Only important for the UI.      Example { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Annotated folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Annotated folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;default-preprocessing\u0026#34; : { \u0026#34;x\u0026#34; : 525, \u0026#34;y\u0026#34; : 100 }, \u0026#34;default-preprocessing{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 }, \u0026#34;default-preprocessing{Horizontal}\u0026#34; : { \u0026#34;x\u0026#34; : 450, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-annotate-by-name\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;default-preprocessing\u0026#34;, \u0026#34;generated-annotation\u0026#34; : \u0026#34;project-sample\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Folders to annotations\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/batch-pipelines/",
	"title": "Batch pipelines",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "JIPipe was designed to always process data in batches, meaning that algorithms always work on multiple data sets at once. This greatly reduces the required work to upscale a processing pipeline from one or few to a large amount of data sets.\nWe will use this pipeline as example:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  In the pipeline, a file is provided as input. Then the file is loaded as image. Finally, the image is processed with a gaussian filter.\nA possible implementation of such a pipeline consists of three algorithms, one for each processing step. An algorithm consumes input and produces output. The exception is the algorithm that loads a user-defined file path into the pipeline.\nJIPipe extends on this concept by allowing input and output slots contain multiple data sets at once. And depending on the algorithm, it either processes each data set individually, or splits, merges, or transforms the list of input data.\nHandling multiple inputs There might be algorithms that require multiple inputs:\nmermaid.initialize({startOnLoad:true}); graph LR; A[Image channel 1] -- B[Merge channels] C[Image channel 2] -- B  The Merge channels algorithm merges the two image channels into one image with two channels. If each data slot only contains one entry, finding image channels that belong to the same data set is trivial.\nFor list-based data slots, like in JIPipe, it is not trivial to find images that should be merged. For example, image1_C1 and image1_C2 should be merged to image1_merged:\nData annotations JIPipe solves this issue by allowing to annotate each data entry (shown as purple entries). Those annotations are in this case automatically extracted and used to group input data. There also can be algorithms that use the annotation information to for example filter or sort data.\nThere are predefined algorithms located within the Annotate menu that for example create annotations based on filenames. JIPipe supports an unlimited amount of annotations that can be attached to data.\nFollowing JIPipe pipeline provides an example of making use of annotations to allow multiple inputs:\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "Binary distribution The download is not available, yet. Please come back later!\nSource code The software is Open Source and licensed under BSD-2-Clause.\nDocumentation You can find a documentation of the Java API here:\nOpen JavaDocs\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/iterating-algorithms/",
	"title": "Handling multiple inputs",
	"tags": [],
	"description": "",
	"content": "JIPipe data slots store multiple data rows. This means that algorithms have to iterate their workload for each input row and generate equivalent output in the respective output slots.\nThere can be issues if data from multiple input slots need to be combined (e.g. merge channels into RGB, see user documentation). JIPipeAlgorithm has no capabilities to help with such cases.\nA solution can be JIPipeIteratingAlgorithm or JIPipeSimpleIteratingAlgorithm that use the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeDataBatch instances that represent one data set iteration.\nFor simple algorithms, we recommend JIPipeSimpleIteratingAlgorithm. It does not have the additional parameters that might confuse some users, but creates the same runIteration(\u0026hellip;) command as JIPipeIteratingAlgorithm. It only works for algorithms with at most one input and will generate error messages if you have more than one input.\n Please access data via the data interface. It reads exactly one JIPipeData for each input.\n The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeIteratingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeDataBatch dataBatch, JIPipeRunnerSubStatus subProgress, Consumer\u0026lt;JIPipeRunnerSubStatus\u0026gt; algorithmProgress, Supplier\u0026lt;Boolean\u0026gt; isCancelled) { // Run your workload here  } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/tutorials/analysis/",
	"title": "Image analysis pipeline",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as video.   1. First start On starting JIPipe, you will see such a screen: It contains a short introduction, the graph compartment editor, an three pre-defined graph compartments Preprocessing, Analysis, and Postprocessing. As described in the graph compartment documentation, you can ignore graph graph compartments. But in this tutorial we will make use of its capabilities to clearly separate the pipeline into the mentioned tree steps.    2. Graph compartments Here you can see how the data flows between graph compartments. You do not have to do anything here, as this is the default configuration. Data flows from Preprocessing to Analysis, and finally to Postprocessing.  You can ignore the graph compartments and of course define your own data flow. Graph compartments are very flexible. Just take a look at the documentation.    3. Preprocessing In this tutorial, the preprocessing step should consist of algorithms that load and organize data for the following processes. To switch to the graph editor for the preprocessing step, just click the Preprocessing tab. You will find an empty graph aside of the Preprocessing output node. We will utilize this node in a later step to pass preprocessed data to other steps.  The graph is stored project-wide. You can just close all graph editors that you do not need for the current task. You can re-open them via the graph compartment editor. If you closed it, you can re-open it via the Compartment menu in the project menu bar.    4. Adding a data source The most common way how data is provided is to load them from files or folders. JIPipe comes preinstalled with data-types and algorithms that handle filesystem operations. The tutorial data is supplied as set of folders that contain the input images as TIFF files in a sub-directory.We begin by adding a data source that supplies a list of folders. You can find it in Add data \u0026gt; Folder \u0026gt; Folder list. After selecting the item, it will appear in the graph.  You can also drag folders and/or files directly into the graph editor area. Corresponding file data source nodes are then created. For this example, you could just drag the input data folders directly into the graph.   You do not have to navigate via the menu. You can also type the algorithm name or some keywords into the bar that reads Search ....    5. Including the input folders Select the newly created algorithm node by clicking it. The panel on the right-hand side will update and allow you to change the parameters of the selected algorithm node. Click the  Add button and select the input folders.  You can save the current project at any time and re-load it later. If you save it in a parent directory relative to where your data is located, JIPipe automatically saves all paths relative to the project file. This means you can just move all your data, including the project to other machines or hard drive partitions without breaking anything.    6. Annotating data JIPipe is designed as batch processing tool, meaning that it can be always scaled from small test data up to large data sets. It can be helpful for you and some algorithms to know which data belongs together. JIPipe introduces the concept of data annotations that assign data to an unique data set and are passed through the pipeline. You can find more about this in the documentation about how JIPipe processes data. In this step we add the data annotation directly at the beginning by attaching the input folder name to each folder that was passed into the pipeline. This is done via the Annotations \u0026gt; Generate \u0026gt; Path to annotation algorithm. Just add this algorithm into the graph. For more advanced projects there are plenty of other sources for annotations, like importing them from tables, or extracting and modifying annotations.   7. Connecting slots The input folders are converted into a format understandable by JIPipe by the Folder list algorithm. The output then can be passed to following algorithms like the Folders to annotations algorithm we added in the last step. To make a connection click the  or  button and select the available data slot. You can see that a connection between the two data slots was created. This list is always sorted from the closest to the farthest away slot.  You can also use your mouse to drag a connection between slots.    8. Annotation type Annotations are like columns in a table - only that our table contains complex data types. The Path to annotation algorithm automatically extracts the path's file name (or directory name) and annotates it to the input row. By default, the algorithm creates a column Dataset. If you want you can change it to another meaningful column name. And with more complex projects you will probably have many different columns.   9. Extracting the image file We have now the folders and can extract the input image file from each one of them. You can find an algorithm designed for such purposed in File system \u0026gt; List \u0026gt; List files. Add it to the graph and connect it to the Subfolder name output. This algorithm is not only able to list files, but also filter them directly. In this case, we exactly know that our files are located within a sub-folder in. Please update the Subfolder parameter by setting it to in. To filter the correct input files, click  Add. Then select  to switch to a glob/wildcard filter and set the filter string to *.tif.  If you have more complicate folder structures, you can apply the \"Navigate to sub-folder\" operation with a distinct algorithm. You can find it in the Filesytem category.    10. Testing if the pipeline is correct (Optional) The Quick Run feature allows you to run the pipeline until the selected algorithm and compare multiple parameter sets. It is a good way to test if the pipeline works so far. To create a quick run right-click the List files node and select  Run \u0026amp; show results.  The quick run will check if the pipeline is valid might show some error. If you think that the pipeline is valid, click  Retry to check the pipeline again. It sometimes does not update for performance reasons.   You can also do a quick-run that just refreshes the Cache.   You can also start a Quick Run from the parameter panel if you select the algorithm.    11. Testing if the pipeline is correct - results (Optional) Navigate to the output if the List files algorithm and check if the file paths are correct. See our Quick Run documentation for more information about the testbench and its features.   12. Importing the images After correctly setting up the files, you can import them as images. You can find various importers for image types in Add data. Our images do not require Bio-Formats, so we choose Add data \u0026gt; Image \u0026gt;Import image. Connect it to the output of List files.  The Import image node does not ensure the exact bit depth and dimensionality of the output image. You can change this via a parameter that allows you to choose the exact image type.    13. Preprocessing output You could continue with the analysis directly from the Import image node. But to showcase the graph compartments feature, we decide to have the imported greyscale image as output for of the Preprocessing compartment. The output of a graph compartment is only interfaced through a special node, in this case Preprocessing output.We first have to define an output slot by clicking the  button. Select Import image, set a name, and click  Add.   14. Connecting the output Finally, connect the output of Import image to the new input slot of Preprocessing output.   15. The analysis Now we are finished with the preprocessing. Switch to the Analysis graph compartment by selecting the tab in the tab bar. You see that it also contains a node called Preprocessing output. This is the same node as in the preprocessing compartment, but it only contains output data this time. We continue the analysis with a Gaussian filter that can be found in Images \u0026gt; Blur \u0026gt; Gaussian blur 2D. Add it to the graph and connect it to the output of Preprocessing output.   16. Finding the particles Add following algorithms to the graph and connect them the the previous output:  Images \u0026gt; Threshold \u0026gt; Auto Threshold 2D Images \u0026gt; Binary \u0026gt; Distance transform watershed 2D Images \u0026gt; Analyze \u0026gt; Find particles 2D   This will create a more or less accurate segmentation of the objects (spores) that are visible in the data. The generated masks are then analyzed to extract ROI and measurements.   17. Analysis output Create multiple analysis output slots via the  button. Export at least the measurements table. In our example, we exported the mask, ROI, and the measurements.  You can hide edges if you want. Just click the  or  and select Hide edge.    18. Postprocessing The postprocessing consists of generating a histogram plot of the spore particle areas. You can find a node that generates plots in Tables \u0026gt; Plot \u0026gt; Plot tables. Connect the measurements to the plotting node and set its plot type to  Histogram plot. You see that the node parameters change. They adapt to the the currently selected plot and expect from you to input from which table column(s) to extract the data from. Either you know the name of the columns, or you can use the testbench to generate output and check it yourself. Some algorithms also write the names of their output columns in their description. The correct column for the measurements is Area. You can also change various plot-specific settings and determine how output images are generated.  The plot node automatically generates SVG and PNG renders in the selected resolution. This is not a definite choice, as JIPipe has its own plot builder that can import generated plots from within the results UI.   Aside from exact matching, plot input columns can be matched via a regular expression or generated. Use the generator by selecting . A generator can be useful if you have no matching column within your data.    19. Running the pipeline To run the pipeline, click the  Run button at the top right corner. This will open a new tab where you can select the output directory. You can also generate a random folder that will be located on your operating system's temporary directory by clicking the button. After setting up the parameters, click  Run now.  JIPipe attempts to prevent the most common errors (such as wrong parameters) and displays a message if something was found. Please follow the instructions of those messages. Depending on the data and algorithms, the behavior might not be forseeable and a crash occurs during the processing. A similar easy-to-understand message is shown on how to proceed or repair the issue.    20. Displaying results After the pipeline was successfully executed, a result analysis interface is shown. It displays the results of all output slots. You can navigate through the results via the tree on the left-hand side. On selecting a row, an interface is displayed below the table that contains various operations to import or open the data.   21. Displaying plots To open the generated plots, navigate to Results \u0026gt; Postprocessing \u0026gt; Plot tables \u0026gt; Output and double-click an entry in the list. Alternatively, you can also select the row and click Open in JIPipe. This will open a new tab with a plot builder tool. Please take a look at the plots and tables documentation for more information how the tool works.   "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/javadocs/",
	"title": "JavaDocs",
	"tags": [],
	"description": "Provides a link to the JavaDocs",
	"content": "The JavaDocs of the Java API can be found here:\n Open JavaDocs  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/data-type/result-ui/",
	"title": "Result view",
	"tags": [],
	"description": "",
	"content": "After processing, users should be able to continue processing the data from within JIPipe. The data instances are cleared from memory after processing, meaning that the data needs to be loaded from its output folder after processing.\nAn user interface is shown when a user select a row in the results table. This UI can be replaced with a custom one that is designed to handle this specific data type.\nSuch UIs inherit from JIPipeResultDataSlotRowUI, which is a panel that has access to\n the data location the annotation of this data row the project workbench UI  We recommend to inherit from JIPipeDefaultResultDataSlotRowUI that allows to inherit actions from inherited data types.\nJIPipeDefaultResultDataSlotRowUI requires you to register actions with a name, description and function. The action that was added last is shown in the main UI and triggered by double-clicking the data row in the table. All other actions are put into the ... menu.\npublic class MyDataDataSlotRowUI extends JIPipeDefaultResultDataSlotRowUI { public MyDataDataSlotRowUI(JIPipeProjectWorkbench workbenchUI, JIPipeDataSlot slot, JIPipeExportedDataTable.Row row) { super(workbenchUI, slot, row); } // This method is required because we need to find the JSON file  // we can load MyData from it  private Path findJsonFile() { if (getRowStorageFolder() != null \u0026amp;\u0026amp; Files.isDirectory(getRowStorageFolder())) { return PathUtils.findFileByExtensionIn(getRowStorageFolder(), \u0026#34;.json\u0026#34;); } return null; } @Override protected void registerActions() { super.registerActions(); Path jsonFile = findJsonFile(); if (imageFile != null) { registerAction(\u0026#34;Show value\u0026#34;, \u0026#34;Shows the value as message box\u0026#34;, UIUtils.getIconFromResources(\u0026#34;open.png\u0026#34;), e -\u0026gt; { MyData data = MyData.fromJson(jsonFile); JOptionPane.showMessageDialog(this, data.value, \u0026#34;The value is ...\u0026#34;) }); } } } The UI class can be directly registered in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, null); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "  Segmenting spores This example applies auto-thresholding to segment spores from microscopy images. It makes use of the particle analyzer to extract ROI and measurements and shows how to create an area histogram plot.\n  Download   Tutorial   Preview graph      More examples will follow later.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/tutorials/analysis_video/",
	"title": "Image analysis pipeline (Video)",
	"tags": [],
	"description": "This step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as text tutorial.   "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/merging-algorithms/",
	"title": "Merging input data",
	"tags": [],
	"description": "",
	"content": "You might need to develop an algorithm that does not simply iterate through its input(s), but organize it into groups to be merged. JIPipe comes with JIPipeMergingAlgorithm that uses the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeMergingDataBatch instances that represent multiple data rows merged into one group.\nPlease access data via the data interface.\n The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeMergingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeMergingDataBatch dataBatch, JIPipeRunnerSubStatus subProgress, Consumer\u0026lt;JIPipeRunnerSubStatus\u0026gt; algorithmProgress, Supplier\u0026lt;Boolean\u0026gt; isCancelled) { // Run your workload here  } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/algorithm/",
	"title": "Algorithm type",
	"tags": [],
	"description": "Defines a new algorithm",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm.schema.json\n Defines a new node type   id:  string       Unique algorithm ID   metadata:  See metadata        General algorithm metadata   category:  string   org.hkijena.jipipe:miscellaneous      The category   exported-parameters:  object   [object Object]     List of parameters that will be exported to users of the node   graph:  See graph        This graph is executed when the algorithm is run   menu-path:  string       Optional menu path within the category menu   jipipe:project-type:  string  , x ∈ { graph-wrapper-algorithm  (default) }       Identifies the JSON as algorithm      Example { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;parameter-visibilities\u0026#34; : { \u0026#34;visible-keys\u0026#34; : [ ] }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/tutorials/extension/",
	"title": "Creating an extension",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.",
	"content": " 1. Existing pipeline In this tutorial, we will create a custom algorithm extension based on parts of the pipeline created in the other tutorial. Please open the project file for the pipeline and navigate to the Preprocessing tab.    2. Selecting the algorithms Please select the following algorithms (you can either do this by holding the Shift keyboard button and clicking the nodes or dragging a selection around the nodes):  Folder list Path to annotation List files Import image  After selecting the algorithms, right-click a selected node and click Export.  Selecting one or multiple algorithms is only one way to create a custom algorithm. You can also export a whole project compartment (via the Compartments tab) or the whole pipeline (via Project \u0026gt; Export as custom algorithm)     3. Preview This will open a new tab where you can see a preview of the pipeline that will be exported. You see that the connections between the selected algorithms were kept, while two additional nodes were added:  Group input Group output  Those two nodes respectively act as input and output of the whole exported algorithm. Its input and output slots will be accessible to users of your custom algorithm. JIPipe automatically creates matching input and output slots based on the selected algorithms, but you can choose to modify your pipeline in this step. Now click Export to extension and then New extension.  You can always modify custom algorithms within the extension builder. This will be shown in a later step.     4. Extension builder This will open the JIPipe extension builder tool that allows you to package one or multiple custom algorithms into an extension. Such extensions can be just put into the ImageJ plugin directory and will be automatically picked up by JIPipe just like any ImageJ plugin. An extension has a set of metadata that you need to set up. To do this, switch to Extension settings.  You can always find the extension builder in Plugins \u0026gt; New JSON extension ...     5. Extension metadata JIPipe utilizes a unique extension ID to identify an extension. This is the most important setting and should be chosen carefully. The format must follow a specific structure: [Author]:[Extension], where [Author] provides information about the extension author, and [Extension] contains some identifier. We recommend to let the [Author] information follow the Maven naming conventions. All the other metadata can be freely chosen or left out (with the exception of the name). Use the other metadata to add authors (including affiliations), a website, define a license, and cite work your pipeline is depending on. Finally, you can review or modify the extension contents by going to Extension contents.  Any dependency to other JIPipe extensions are automatically stored within any project or extension file. JIPipe uses this information to figure out a valid load order.     6. Extension content Our custom algorithm is already included in the list of extension contents (left-hand side). You only need to provide metadata. The most important setting is the unique algorithm ID that is used by JIPipe to identify your algorithm. Please choose a meaningful string that avoids having duplicate identifiers. Then you can provide a name, category, icon and menu location.  The extension builder will warn you if an algorithm ID already exists (we will show this function later). You can choose to ignore this if a duplicate ID is intentional - this will override an algorithm and replace it by the new one.   Algorithm IDs are not namespaced, meaning that they are independent of the extension ID.     7. Parameters By default, your algorithm does not come with parameters aside of the few default parameters (name, description, pass-through, enable). For your pipelines it can be useful to let users change some parameters. The Exported parameters section gives you full control on which parameters can be changed and how they are organized. First, you need to create a group by clicking the  Add group button. This will create a new section in the final parameter UI. Then you can reference parameters by clicking  Add parameter. You can customize the name and descriptions of any item.  It is always a good idea to check the parameters or maybe apply some corrections to the algorithm. To do this, click  Edit graph  You can just add all parameters of a specific algorithm by clicking Auto add algorithm. Just check if users can properly decipher the function of each parameter.   Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references.     8. Modifying the algorithm The extension builder contains a fully function algorithm graph editor (aside of anything that runs the graph) that allows you to modify an algorithm or create one from scratch. Use the editor to check the parameters of your algorithm. For example, it is a good idea to remove the folders from the Folder list algorithm.    9. Validation and installation Click the  Validate button on the top right corner to check for any issues. This tool will also detect duplicate extension and algorithm IDs. Errors about duplicates can be ignored if they are intentional.  Finally, you can install the extension by clicking  Install. This will open a dialog to save the extension into the ImageJ plugin directory and attempt to load the extension.  We still recommend to restart ImageJ, especially if you are installing duplicate IDs.     10. Using the algorithm You can find your algorithm in the menu, navigation bar, and algorithm finder just like any other algorithm. You can see that the parameters are included according to the settings within the extension builder.  JSON Algorithms can be always converted into  Group nodes that unlink the underlying pipeline from the JSON algorithm definition and allows users to modify them. Just select  Convert to group to apply such conversions.    Group nodes are related to JSON algorithms. If you export a single group node, its contents are exported into an algorithm instead of the node itself.     "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/create-extension/",
	"title": "Creating an extension project",
	"tags": [],
	"description": "Explains how to setup a SciJava plugin project to extend JIPipe",
	"content": "Prerequisities  Java 8 (Java 9+ are not working)  If you are using Windows or a Linux distribution without Java 8, we recommend AdoptOpenJDK (Please choose OpenJDK 8)   Maven  Creating the project The project should have following structure:\nProject root └── pom.xml └── src └── main ├── java └── resources Both the java and resources folder should contain a folder structure that is equivalent the groupId and artifactId of the project. This is done to prevent conflicts with other plugins.\nJIPipe is based on SciJava and requires libraries provided by the SciJava Maven repository.\nHere is an example *.pom file that makes use of SciJava:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;inceptionYear\u0026gt;2020\u0026lt;/inceptionYear\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;distribution\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/distribution\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;id\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;archive\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/connection\u0026gt; \u0026lt;developerConnection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/developerConnection\u0026gt; \u0026lt;tag\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/tag\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pom-scijava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;28.0.0\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;imagej.public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://maven.imagej.net/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;external-jars\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;External JAR files\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;file://${project.basedir}/external-dependencies\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imglib2\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imglib2-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej-legacy\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-log-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JIPipe core library --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- ImageJ integration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Add more JIPipe libraries if you need --\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;license.licenseName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.licenseName\u0026gt; \u0026lt;license.copyrightOwners\u0026gt;N/A\u0026lt;/license.copyrightOwners\u0026gt; \u0026lt;license.projectName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.projectName\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- This plugin can be useful to create a manually-installable package --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/dependencies\u0026lt;/outputDirectory\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;false\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;excludeGroupIds\u0026gt;net.imagej, net.imglib2, org.scijava, com.google.code.gson, com.google.guava, org.swinglabs, ome \u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;set-rootdir\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;set-rootdir\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-jars\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;install\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-jars\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Creating an extension service JIPipe uses the SciJava plugin API to register Java extensions. In your project, you can create as many extensions as you want.\nJava extension inherit from JIPipeJavaExtension and require a @Plugin annotation.\nWe recommend to inherit from JIPipeDefaultJavaExtension that comes with some convenience-functions.\nA minimal extension can be found here:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { @Override public String getName() { return \u0026#34;My extension\u0026#34;; } @Override public String getDescription() { return \u0026#34;A Java extension\u0026#34;; } @Override public String getDependencyId() { // We recommend the following structure: \u0026lt;groupId\u0026gt;.\u0026lt;artifactId\u0026gt;:\u0026lt;dependencyId\u0026gt;  // (!) The dependency Id should be unique for your plugin (!)  return \u0026#34;org.hkijena.jipipe:my-extension\u0026#34;; } @Override public String getDependencyVersion() { return \u0026#34;1.0.0\u0026#34;; } @Override public String getAuthors() { return \u0026#34;Ruman Gerst\u0026#34;; } @Override public String getWebsite() { return \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;; } @Override public String getLicense() { return \u0026#34;BSD-2\u0026#34;; } @Override public URL getLogo() { // This code loads the default JIPipe logo from JIPipe resources  // You can replace it with your own logo if you want  // Just do not use JIPipe\u0026#39;s ResourceUtils for this, as its always pointing to JIPipe resource directories  return ResourceUtils.getPluginResource(\u0026#34;logo-400.png\u0026#34;); } @Override public String getCitation() { // Here you can enter a citation for your publication  // It will be displayed in the plugin manager  return \u0026#34;\u0026#34;; } @Override public void register() { // Content is registered here  } } Testing your extension Use following code to create an ImageJ2 instance that immediately loads JIPipe:\npublic static void main(final String... args) { final ImageJ ij = new ImageJ(); ij.ui().showUI(); // If your ImageJ freezes, you can leave this out. JIPipe will show anyways.  ij.command().run(JIPipeGUICommand.class, true); } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/slot-configuration/",
	"title": "Customizing slots",
	"tags": [],
	"description": "",
	"content": "In the previous examples, we used the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations with autoCreate = true to automatically configure the slots.\nThis is not sufficient for more complicated algorithms that require\n Restricting the number of slots Restricting the allowed data types Users to add more slots or remove existing ones  A custom JIPipeSlotConfiguration can be used to implement such more advanced behaviors.\nFor many cases, the default implementation JIPipeMutableSlotConfiguration is sufficient.\nThe slot configuration can be overriden during instantiation of the algorithm:\npublic MyAlgorithm(JIPipeNodeInfo info) { super(info, JIPipeMutableSlotConfiguration.builder() .addInputSlot(\u0026#34;Input\u0026#34;, ImagePlusData.class) .restrictOutputTo(ImagePlusData.class) .build()); }  The slots of JIPipeMutableSlotConfiguration are by default unsealed - meaning that users can add more slots. Use the seal() functions to prevent this.\n Do not create static slot configurations. Each algorithm should have its own instance. Use a private static function if you want to work outside the capabilities of the builder.\n You should keep the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations. They are required for the algorithm finder and generating tooltips.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "This library provides integration of ImageJ data types, as well as common ImageJ algorithms.",
	"content": "The ImageJ integration library integrates common data types from ImageJ into JIPipe:\n Multi-dimensional images (ImagePlus). The standard output file format are TIFF files. Result tables. They are serialized to CSV files. Region of interest (ROI Manager). JIPipe handles ROI as *.zip files.  The ImageJ data types are marked as accessible from outside JIPipe, meaning that algorithms that only use those types can be executed standalone\nImage data types Various ImageJ algorithms only work on data with a specific color type, or dimensionality. To make it easier for algorithms to specifiy which types are suitable, the JIPipe standard library introduces various image sub-types (e.g. 8-bit greyscale 3D image).\nThe library is set up to automatically convert any image data type into any other image data type. During this conversion, the data types automatically attempt to satisfy their constraints or raise an error. The conversion automatically converts a lower-dimensional image into a higher-dimensional image (e.g. 2D to 3D), but not the other way around.\nThe image data types are organized in the following way:\nmermaid.initialize({startOnLoad:true}); graph LR; ImgPlus[\"Image (nD)\"] -- ImgPlusGreyscale[\"Greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale8U[\"8-bit greyscale image (nD)\"] ImgPlusGreyscale8U -- ImgPlusGreyscaleMask[\"8-bit mask (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale16U[\"16-bit greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale32F[\"32-bit float greyscale image (nD)\"] ImgPlus[\"Image (nD)\"] -- ImgPlusColor[\"Color image (nD)\"] ImgPlusColor -- ImgPlusColor8U[\"8-bit color image (nD)\"] ImgPlusColor -- ImgPlusColorRGB[\"RGB color image (nD)\"]  The graph above shows the structure for non-dimensional (nD) images. This structure is repeated for 2D, 3D, \u0026hellip; 5D images.\nColor space conversions are automatically applied (e.g. from RGB to greyscale). While trivial for specific color types (like RGB color), JIPipe falls back to following color spaces for generic colors (e.g. greyscale image):\n   Color space Fallback colorspace     Greyscale 32-bit float greyscale   Color RGB color    Frequency space image data types The JIPipe standard library contains color types that are intended to hold frequency-space (FFT) data. While the standard library only provides methods to handle 2D FFT, there are 3D, \u0026hellip;, 5D data types available for future extensions.\nWe rely on the mechanisms provided by ImageJ. For example, the ImageJ FFT generates a 8-bit greyscale power spectrum image and attaches data to the image instance. JIPipe has no special methods to load and save the FFT data, aside from the image data itself. We recommend to generate FFT data within the pipeline to generate the correct data.\n ImageJ algorithms The standard library provides a selection of common ImageJ algorithms as JIPipe algorithm nodes. Those algorithms wrap around the respective ImageJ methods and have the same feature set, aside from some changes that are required to make algorithms usable in a batch-environment like JIPipe.\nYou can find a list of all algorithms via the  Help menu on the top right corner and the item Algorithm compendium.\nYou can run ImageJ macro code as node. The input slot names correspond to the image windows that are created. Macro nodes do not work in a headless (server) environment, so be careful when including them.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/multi-parameter/",
	"title": "Multi-parameter algorithms",
	"tags": [],
	"description": "This library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.",
	"content": "Most algorithms allow handling of multiple parameters via an additional slot that can be optionally enabled. You can find the setting in an algorithm\u0026rsquo;s settings as Multiple parameters. On selecting the item, a new slot will appear that consumes parameter data.\nTo define parameters, use the algorithms found in Add data \u0026gt; Parameters. There are currently two data source algorithms available:\n Define parameter defines a single set of parameters Define multiple parameters lets you define a table of parameters  Use Process \u0026gt; Merge \u0026gt; Merge slots to merge multiple parameter sets.\n Defining parameters Both data sources require you to determine which parameters should be created. To do this, add parameters into the Parameters section (red box).\nFor Define multiple parameters, there is an additional element (blue box) that contains a parameter table. Each row represents a parameter set, while a column represents a parameter type. Columns can be added by adding parameters into the Parameters section.\nYou can leave the table empty. In this case, the parameters are extracted from the \u0026lsquo;Parameters\u0026rsquo; section.\n Select a table cell to open the parameter editor below the table.\nThere are following buttons available:\n Add row adds a new row with standard parameters Generate row allows you to create new rows where one column is generated by the selected generator Replace cells allows you to replace the selected cells in one column with a set of generated parameters  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/graph-editor/",
	"title": "Pipeline editor",
	"tags": [],
	"description": "Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.",
	"content": "The graph editor (pipeline editor) allows you to edit the processing steps of a graph compartment. Its user interface is separated into three sections:\n The analysis graph contains the processing steps (also referred as algorithms) The settings panel shows the properties of the currently selected algorithms The toolbar allows you to add more algorithms into the graph, navigate to existing algorithms, change some behavior settings of the graph editor, and create screenshots  Analysis graph The analysis graph contains algorithms that are represented by rectangles. The algorithm graph area will automatically grow depending on where you place the algorithms. Scroll bars will appear if the graph area is larger than the available screen size.\nAn alternative to using the scroll bars is to hold the middle mouse button while dragging the your mouse.\n Algorithms read data from their input slots and output the results into the output slots. There are some algorithms that do not have input slots - they produce output based on their current parameters. The algorithm user interface has three sections:\n Input slots are located on the top of the algorithm UI. Each slot has a unique name that is displayed below the arrow. The arrow opens a menu that allows you to make/modify connections or change other options specific to the slot. Depending on the algorithm, a + button is created that allows you to add more slots. The drag area allows you to move the algorithm around. Move your  mouse pointer over the area and drag your mouse while holding the 🖱 left mouse button. On clicking the  button, a menu will open that contains some algorithm options. Alternatively you can right-click the drag area to open this menu. Output slots are located on the bottom and allow you to connect your output data to the input of another algorithm.  Any output data is always saved automatically by JIPipe. After generating the final output data, there is no need to connect it to any input.\n Slot connections You can connect two slots by clicking the  or  button of a slot and by selecting the source/target slot. Input slots can only receive one connection, while outputs can be distributed to as many inputs as you wish. The selection menu shows all available target slots and its sorted from the nearest to the slot that is furthest away.\nA connection is shows as line between the connected slots. The color of the line indicates if this connection is valid or invalid depending on the data types of the source and target.\n A black line indicates that the data types match exactly. A blue line indicates that the types dont match exactly, but can be converted by JIPipe A red line indicates that the types are incompatible. You will probably get an error message during the calculation.  Hover with your mouse over a slot\u0026rsquo;s name to show information about its data type.\n Slot options The slot context menu opened by  or  contain additional entries to managing connections.\n  Label this slot allows you to give the slot a custom name without changing the internal workings of the algorithm (As many algorithms are designed to adress specific slots). On selecting the entry, you can give a custom name that is displayed in cursive. To remove the custom label, label it with an empty text.  Find matching algorithm \u0026hellip; (only output slots) opens a tool that lists all compatible algorithms that can receive the output data as input. Depending on the algorithm, you can remove a slot from within this menu  Algorithm settings The algorithm settings are displayed on the right-hand side and contain all settings of the selected algorithm. There are usually four categories:\n  Parameters contains general parameters, like the name displayed in the drag area, and algorithm-specific parameters like thresholds, the selection of methods, and other parameters.  Slots is an alternative to modifying slots via the algorithm UI. Here, you can also re-order slots.  Annotations is an alternative to modifying slot annotations via the algorithm UI. See above for more info about annotations.  Quick run is a tool to run the analysis only up to the selected algorithm. It allows you to try and compare multiple parameters without creating new nodes. See the testbench documentation for more info.  Toolbar The toolbar contains functions to add new algorithms into the graph, navigate to existing algorithms or search the list of available algorithms, and functions to control the algorithm graph display.\n On the left-hand side you can find a menu containing all available algorithms. On selecting an entry, the corresponding algorithm is added to the graph. The navigator allows you to quickly navigate to an existing algorithm instance or create a new one. Just type one or multiple search terms into the field. On pressing the  arrow down key on your keyboard, the first entry is selected. The view options control how the graph editor behaves and contains some additional utility functions.  View options  and allow you to switch between horizontal and vertial view modes. This does not change the pipeline, but just how it is displayed in the editor. By default, a vertical view is enabled. If you prefer that data flows from left to right, choose the horizontal view mode. automatically aligns all nodes in the algorithm graph according to the algorithm by Sugiyama et. al allows you to change how dragging the middle mouse button changes the current view. is enabled by default and makes it that nodes are automatically aligned on creating connections. This feature does not reorganize the whole graph, but only places the target algorithm to a location that better represents the data flow. crops the graph area to the area taken by the algorithm nodes. Use this tool to find your nodes after scrolling too far away. creates a screenshot of the whole graph compartment that is currently being displayed.  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/data-type/result-preview/",
	"title": "Preview from results folder",
	"tags": [],
	"description": "",
	"content": "While JIPipeData allows you to define a function for previewing, this only works for data already present in memory. To allow previewing of data stored in a results folder, you need to suppy a JIPipeResultDataSlotPreviewUI that loads the data from disk and generates a preview. We recommend to use JIPipeAsyncResultDataPlotPreviewUI, which only requires you to supply a method for loading the data from disk. This class will offload the loading and preview generation into a separate thread to prevent the UI from freezing.\npublic class MyDataPreviewUI extends JIPipeAsyncResultDataPlotPreviewUI { public MyDataPreviewUI(JTable table) { super(table); } @Override protected JIPipeData loadData(Path storageFolder) { Path jsonFile = PathUtils.findFileByExtensionIn(storageFolder, \u0026#34;.json\u0026#34;); return MyData.fromJson(jsonFile); } } The preview class is registered as last argument of registerDataType():\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, MyDataPreviewUI.class); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "This section contains video and text tutorials for the most common tasks done with JIPipe. First, let\u0026rsquo;s describe what JIPipe is and what it does for you.\nJIPipe is short for Java Image Processing Pipeline and provides a graphical programming language to design batch image processing pipelines, while solving some of the scalability issues that arise with other graphical programming languages.\n Introducing a powerful extension system that can integrate image analysis algorithms without losing usability Introduction of powerful filesystem handling that can be adapted to any data organization A powerful, yet easy-to-understand graphical programming language that was designed from the get-go for flexible scaling, and assisting the user as much as possible  Why JIPipe? JIPipe is a user-friendly alternative to ImageJ macro or script programming that brings following benefits to you:\n JIPipe is a batch processing tool. This means that you can scale your analyses up to larger or down to smaller data sets without modifying the whole pipeline JIPipe runs headless. Your pipelines generally work in environments without a graphical interface, like compute servers JIPipe has strong typing. Data types are well defined and you immediately see if and how data is converted into another format, bit depth, or dimensionality JIPipe standardizes parameters and output. A common issue is the question how to arrange the generated analysis outputs and how to save parameters. JIPipe does all of this for you completely automatically. For example, output files are written into a standardized filesystem hierarchy that allows third-party programs to read results automatically. JIPipe standardizes metadata. It comes with an powerful functionality to attach metadata to your data that can be queried and manipulated. All metadata is stored automatically in the results in standardized formats. JIPipe has a powerful standard library. It comes with many common ImageJ algorithms - with enhanced usability and designed for batch-processing, as well as tools for handling tables and creating or modifying plots. JIPipe can be extended without programming. You do not need programming knowledge to publish your own algorithms. Just export your pipeline or parts of it as extension from within a GUI  Tutorial list  Image analysis pipeline\nThis step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Image analysis pipeline (Video)\nThis step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Creating an extension\nThis step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.\n  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/",
	"title": "Creating an algorithm",
	"tags": [],
	"description": "Explains how to create a custom algorithm",
	"content": "All algorithms inherit from JIPipeAlgorithm. An algorithm consists of following parts:\n A run() function that runs the workload A reference to an algorithm info that describes the general properties of the algorithm A slot configuration that describes which slots the algorithm should have  JIPipe comes with different base algorithms that provide different feature sets:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Any algorithm should have the following basic structure:\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots autoCreate automatically creates the slots if set to true and no slot configuration was provided @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation */ @Override public run(JIPipeRunnerSubStatus subProgress, Consumer\u0026lt;JIPipeRunnerSubStatus\u0026gt; algorithmProgress, Supplier\u0026lt;Boolean\u0026gt; isCancelled) { // Run your workload here  } } To register the algorithm and provide it with an Id, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // Registers our algorithm with a unique ID and an icon  registerNodeType(\u0026#34;my-algorithm\u0026#34;, MyAlgorithm.class, UIUtils.getIconURLFromResources(\u0026#34;actions/viewimage.png\u0026#34;)); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/dependency/",
	"title": "Dependency",
	"tags": [],
	"description": "Project or extension dependency. Refers to an JIPipe extension.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: dependency.schema.json\n Project or extension dependency. Refers to a JIPipe extension.   metadata:  See metadata         id:  string       Unique ID of this dependency should have format  .  :       version:  string       Version of this dependency      Example { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "This section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work.\nBatch processing JIPipe is a tool to create data processing workflows via a graphical language. A special feature of JIPipe processing is always done in batches, meaning that workflows are always designed to scale for large amounts of data without the need of external scripts or major changes in a pipeline.\nThe JIPipe graphical language is graph-based where nodes represent data processing algorithms and edges represent that data is transferred from an algorithm output to another algorithm\u0026rsquo;s input.\nAn example is the application of a gaussian filter to an image after loading it:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  To design efficient and scalable pipelines yourself, it is a good idea to look into the JIPipe data model.\nGraph compartments A common issue with graphical programming languages is that larger pipelines are hard to navigate. Another issue with such languages is that it is hard to separate functional units for easier readability.\nJIPipe solves both issues with the concept of strongly separated graph components that group a set of algorithms together. Components only can interact via special interface algorithms, making it easier to structure the pipeline.\nPlease take a look at our graph compartment documentation for more information.\nUser interface overview The JIPipe user interface is designed around managing an analysis project. A project contains all information to run an analysis, outside of the input data and can be saved into JSON files. The user interface is separated into three sections:\n The project menu contains all operations for the current project / window. It allows you to open/save projects, access and modify graph compartments, manage plugins, and run the analysis The tab bar allows you to switch between different interfaces associated to the current project. You can close thabs by clicking the x icon. If a tab contains some data that will be lost after closing it, you will have to confirm the action. If no question is asked on closing a tab, you will be able to open it later again without losing data. The current content depends on the selected tab  You can also close a tab by clicking it with the middle mouse button.\n Further reading  Batch pipelines\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n  Pipeline editor\nExplains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.\n  Graph compartments\nExplains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n  Running a pipeline\nExplains how to run a pipeline and navigate through the results.\n  Testing algorithm parameters\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n  Data caching\nExplains the how JIPipe caches intermediate results and how to access them.\n  ImageJ integration\nExplains functionality that allows ImageJ to run JIPipe algorithms or pipelines.\n  Managing plugins\nExplains how to install and manage plugins.\n  Standard library\nContains some explanations about the algorithms that are included in the JIPipe standard distribution.\n  Extension builder\nExplains the extension builder tool\n  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/filesystem/",
	"title": "Filesystem algorithms",
	"tags": [],
	"description": "This library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.",
	"content": "The JIPipe standard library contains data types and algorithms to apply file system operations. The common use case is to extract the list of input files for the following algorithms.\nThe filesystem library has two basic data types:\n A  File contains a path to a file A  Folder contains a path to a folder A Path contains a path to a file or folder  In the Add data menu you can define one file/folder or a list of files/folders.\nWe recommend to create a list of files/folders. This makes it easier to scale your workflow up.\n Drag any set of files or folders into the graph editor to create corresponding file/folder data source algorithms.\n File/folder manipulation algorithms The standard library comes with various algorithms that apply common operations to input filesystem data. This includes listing the files in a folder, filtering files/folders, or navigating to a subfolder. They are placed in the Filesystem category.\nAutomated relativization File and folder data source algorithms by default store absolute paths. If you save your project in a parent folder where the data is stored, the paths are automatically converted into relative paths that make data transfer between devices easier.\nAnnotation It is helpful to add data annotations to the file data at some point. This allows algorithms and users to assign data rows to an unique data set. See the annotation standard library documentation for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/graph-compartment/",
	"title": "Graph compartments",
	"tags": [],
	"description": "Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.",
	"content": "A common issue with graphical programming languages is that large graphs are hard to navigate. JIPipe solves this issue by separating the pipeline graph into sub-graphs. Each sub-graph has a predetermined output node that is visible to other compartments. Other nodes on the other hand are not visible to other compartments.\nThe difference between compartments and simple node groups is that compartments only communicate with each other via the compartment output node. JIPipe also only allows you to edit a specific compartment, instead of the whole graph. By default, JIPipe creates three compartments: Preprocessing, Analysis, and Postprocessing.\nBy default a compartment\u0026rsquo;s output node is not visible in any other compartment. The have to be connected in a similar manner on how algorithms are connected. To do this, use the compartment editor that is described in the following section.\n You can ignore the compartment feature if you want. You can delete the default compartments without any issue. Just leave one graph compartment and edit the remaining one.\n Compartments behave similar to algorithms. This means you can create a directed acyclic graph of compartments.\n Creating and connecting compartments JIPipe comes with an editor that allows to control the graph compartments. This editor is similar to the pipeline editor and allows you to create new compartments, connect them, as well as import or export compartments. Instead of containg algorithms, the editor contains graph compartment nodes that can be connected similar to how algorithms are connected.\nYou can one or multiple compartments in the editor. Click the  Edit button to open the compartment in the pipeline editor.\nYou can also double-click a compartment node to open the editor.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": "You can add parameters to your algorithm by creating a property with a getter and setter. Then you annotate the getter and setter with the same @JIPipeParameter keys. Also add an @JIPipeDocumentation annotation to either the getter or setter.\nParameters are automatically serialized and deserialized.\nPlease make sure to send an event when the parameter is set, so the UI can update.\n// ... see previous tutorials public class MyAlgorithm extends JIPipeIteratingAlgorithm { private float roundness = 0.5f; // ... see previous tutorials  @JIPipeParameter(\u0026#34;roundness\u0026#34;) @JIPipeDocumentation(name = \u0026#34;Roundness\u0026#34;, description = \u0026#34;Value within [0, 1]\u0026#34;) public float getRoundness() { return roundness; } @JIPipeParameter(\u0026#34;roundness\u0026#34;) public boolean setRoundness(float roundness) { if(roundness \u0026lt; 0 || roundness \u0026gt; 1) return false; // Reject this value  this.roundness = roundness; // Send the change out to listeners  getEventBus().post(new ParameterChangedEvent(this, \u0026#34;roundness\u0026#34;)); } }  Your setter can return a boolean. If the output is true, JIPipe considers the value as valid. If false, the JIPipe UI re-loads a valid value via the getter.\n Please make sure that your parameter key is unique. Only one getter and one setter should have the same key.\n Not all data types are supported. Data types are registered into JIPipe and available via JIPipeUIParametertypeRegistry.getInstance(). In a later tutorial we show how to register custom data types. JIPipe supports common primitives like boolean, int, float, double, String, and all enum data types.\n Parameter settings Some parameter types have different styles or other settings that can change the behavior of the parameter editor UI. An example is StringParameterSettings that allows to change between single-line and multi-line editors.\nSub-parameters JIPipeAlgorithm, like any JIPipeParameterHolder allows sub-parameters.\nTo create a sub-parameter create a getter to an JIPipeParameterHolder and annotate it with @JIPipeParameter. The key provided with the annotation should be an unique parameter key. The parameters in the sub-parameter instance are automatically displayed as new group in the parameter editor.\nPlease do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. You can use the registerSubParameter() method in the constructor and copy constructor as a shortcut.\n User-defined parameters If you want to make it possible for users to create custom parameters, create an JIPipeDynamicParameterHolder as sub-parameter. You can control the list of allowed parameter types and other settings.\n Do not forget to deep-copy the JIPipeDynamicParameterHolder. The class has a copy constructor for such an operation.\n Please do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. JIPipeAlgorithm comes with a pre-made function registerSubParameters() that should be called in the constructors.\n Full control You can inherit from JIPipeCustomParameterHolder to define all parameters manually without the need for an JIPipeDynamicParameterHolder or annotations.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/parallelization/",
	"title": "Parallelization",
	"tags": [],
	"description": "",
	"content": "The current version of JIPipe supports parallelization via a fixed thread pool. Parallelization is done on an per-algorithm-level, meaning that the algorithms are responsible for providing parallelization capabilities.\nThe included base algorithms JIPipeIteratingAlgorithm, JIPipeSimpleIteratingAlgorithm, and JIPipeMergingAlgorithm already come with support for parallelization that has to be manually enabled via code. The inherit from JIPipeParallelizedAlgorithm and completely apply parallelization automatically.\nAutomated parallelization (JIPipeParallelizedAlgorithm) The automated parallelization is controlled by three factors:\n If the user enabled parallelization via a parameter If parallelization is supported In how many batches the data is separated  To enable parallelization, let supportsParallelization() return true (defaults to false). This will parallelize the processing of data interfaces (see previous chapters). As sometimes third-party algorithms apply their own parallelization, you can restrict how many threads are allocated by JIPipe by setting getParallelizationBatchSize.\nFor example, there are many image analysis algorithm implementations that use Runtime.getRuntime().availableProcessors() for their own parallelization. To ensure that only as many threads as the user selected are allocated, return Runtime.getRuntime().availableProcessors() from getParallelizationBatchSize(). The implementation then will adapt to this value.\npublic class MyAlgorithm extends JIPipeIteratingAlgorithm { /* Enable parallelization. By default false. */ @Override isParallelizationEnabled() { return true; } /* Assume that each runIteration() executes a third-party algorithm with its own parallelization based on Runtime.getRuntime().availableProcessors() threads. Tell this to the JIPipe implementation to limit the number of threads. */ @Override getParallelizationBatchSize() { return Runtime.getRuntime().availableProcessors(); } } Manual parallelization You can choose to do your own parallelization (leave isParallelizationEnabled() to return false). Each JIPipeAlgorithm object has a method getThreadPool() that returns the thread pool assigned to the current run. Please note that this thread pool can be null.\nThe thread pool provides methods to schedule workloads. If the number of threads is set to 1, the thread pool will schedule the workload into the current thread. You also have raw access to the ExecutorService behind the thread pool - just do not forget that the service can be null.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/algorithm/custom-info/",
	"title": "Custom algorithm info",
	"tags": [],
	"description": "",
	"content": "In the previous tutorials we used the standard way of creating algorithms. This might not be sufficient if you want to generate algorithms, for example by importing ImageJ algorithms, loading algorithms from JSON or generate algorithms for an unknown list of data types.\nHow algorithms are registered Algorithm instances are created by an JIPipeNodeInfo. This info is the object that is actually registered into JIPipe. It is able to create new instances of the declared algorithm, or copy it. It also carries basic metadata such as a name, description, or annotation preferences.\nDeclarations should be unique and have a unique ID within the JIPipe algorithm registry.\nOn registering an algorithm like in previous tutorials, following code is run:\npublic void registerNodeType(String id, Class\u0026lt;? extends JIPipeAlgorithm\u0026gt; algorithmClass) { registerNodeType(new JIPipeJavaAlgorithmRegistrationTask(id, algorithmClass, this)); } The code generates a task that just checks if all algorithm dependencies are loaded. If all dependencies are available, the task runs:\nJIPipeAlgorithmRegistry.getInstance().register(new JIPipeJavaAlgorithmDeclaration(id, algorithmClass), source); The important bit is JIPipeJavaAlgorithmDeclaration. In the end an algorithm info is created that extract algorithm information from the class annotations.\nCreating a custom info To create a custom info, inherit from JIPipeNodeInfo. The most important functions are clone() and newInstance().\nRegister the info either via a direct call to registerNodeType(JIPipeNodeInfo) or (recommended) via a task that inherits from JIPipeAlgorithmRegistrationTask. You can inherit from the default implementation JIPipeDefaultAlgorithmRegistrationTask that comes with pre-made functionality to check for common dependencies. The reason behind using a task is that some algorithm-internal classes might require that data types or annotation types are already registered.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/graph-edge/",
	"title": "Graph Edge",
	"tags": [],
	"description": "Edge in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph-edge.schema.json\n Edge in a graph   source-node:  string       Algorithm ID of the edge source   target-node:  string       Algorithm ID of the edge target   source-slot:  string       Slot name within the edge source algorithm   target-slot:  string       Slot name within the edge target algorithm      Example { \u0026#34;source-node\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-node\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/",
	"title": "Java API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe Java API that allows you to create SciJava plugins to extend JIPipe. The Java API is very powerful and allows you to add algorithms, annotation types and new data types. It also allows you to create UI-only components such as parameter editors, plots, and table processing operations.\nYou can refer to the JIPipe JavaDocs for more information about the API specifics. The following tutorials will show you to implement your own Java extensions via small examples.\n JavaDocs\nProvides a link to the JavaDocs\n  Creating an extension project\nExplains how to setup a SciJava plugin project to extend JIPipe\n  Creating an algorithm\nExplains how to create a custom algorithm\n  Creating a data type\nExplains how to create custom data types\n  Creating a parameter type\nExplains how to create an UI for a parameter\n  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/result-analysis/",
	"title": "Running a pipeline",
	"tags": [],
	"description": "Explains how to run a pipeline and navigate through the results.",
	"content": "JIPipe stores its results in a user-defined output folder. After clicking  Run (located at the top right corner of a project window) JIPipe will query the output folder from you. You can also generate a random folder that will be located on your operating system\u0026rsquo;s temporary directory by clicking the button.\nAfter confirming the settings by clicking  Run now, JIPipe will start processing the pipeline.\nYou can have as many runs as you want. Runs will not execute in parallel, but be scheduled to wait until the current run finishes.\n The JIPipe output folder is automatically organized in a standardized way, so JIPipe can open a result folder. You find the \u0026ldquo;Open analysis output \u0026hellip;\u0026rdquo; button in the \u0026ldquo;Project\u0026rdquo; menu.\n Result analysis After all results are generated, the result analysis UI will be automatically opened. It allows you to navigate through the results, and import them back into ImageJ (if supported by the generated data type).\nThe UI has two main components:\n The slot tree shows a hierarchy of all data slots. It is organized by compartment, then algorithm, and finally data slot. By selecting any of the entries, all data associated to the selection or any n-child is displayed. The output data table lists the stored data of the selected slot(s) as table (if you are unfamiliar why this is, please take a look at the explanation on how JIPipe processes data)  After selecting a set of slots in the slot tree the output data table will update to only display the data of the selected slots. The table has following columns:\n (Optional) Compartment shows in which graph compartment the generating algorithm is located (Optional) Algorithm shows the name of the algorithm that generated the data. Location is the folder name where the data is located relative to the slot directory Data shows a string representation of the data row. The contents vary depending on the slot data type. For example, file system data display their path at this location. Additional columns correspond to the data annotations that were attached by various algorithms  Importing results back into JIPipe/ImageJ/\u0026hellip; On selecting one or multiple rows, additional UI elements are displayed below the table. They contain various actions that can be applied to the output data, such as opening the results directory, importing the data back into ImageJ or JIPipe, or any other operation.\nDouble-click a row to execute the default action, which is the one most commonly used.\n -- "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/data-type/",
	"title": "Creating a data type",
	"tags": [],
	"description": "Explains how to create custom data types",
	"content": "Custom JIPipe data types must inherit from JIPipeData. It is required to add an @JIPipeDocumentation annotation that provides a name and brief description of the data type.\nJIPipe requires that data can be saved to a folder within the output directory. We also recommend that you include code that can load the data back into JIPipe or ImageJ in some form.\nThere are no requirements on the constructor of the data type.\nThe folder that is provided in storageFilePath is unique to the data and empty. The name parameter in storageFilePath is usually the data slot name and can be used as template for file names or ignored.\nThere are two optional functions that you can override:\n display() shows the data in ImageJ, JIPipe, or any other GUI preview() generates a GUI component that acts as thumbnail/preview of the contained data  public class MyData implements JIPipeData { String value; public MyData() { } // Constructor that initializes the data  public MyData(String value) { this.value = value; } @JsonGetter(\u0026#34;value\u0026#34;) public String getValue() { return value; } @JsonSetter(\u0026#34;value\u0026#34;) public String setValue(String value) { this.value = value; } // This should return a deep copy  @Override public JIPipeData duplicate() { return new MyData(value); } // The display method is optional, but recommended  @Override public void display(String displayName, JIPipeWorkbench workbench) { JIPipeTextEditor editor = JIPipeTextEditor.openInNewTab(workbench, displayName); editor.setMimeType(getMimeType()); editor.setText(data); } // The preview method is optional, but recommended for many cases  // The width and height are guidelines you should adhere to (especially the height)  @Override public Component preview(int width, int height) { // This example would overlap with toString()  return new JLabel(value); } // Do not forget to override this  @Override public String toString() { return StringUtils.orElse(value, \u0026#34;\u0026#34;); } @Override public void saveTo(Path storageFilePath, String name) { try { JsonUtils.getObjectMapper().writeValue(storageFilePath.resolve(name + \u0026#34;.json\u0026#34;).toFile(), this); } catch(Exception e) { throw new RuntimeException(e); } } // We will use this method later to load the data back from disk  public static MyData fromJson(Path jsonFile) { try { return JsonUtils.getObjectMapper().readValue(jsonFile.toFile(), MyData.class); } catch(Exception e) { throw new RuntimeException(e); } } }  You can use JIPipe\u0026rsquo;s JsonUtils class to get access to a Jackson JSON ObjectMapper.\n Do not forget to override toString(), as the string representation will be displayed in the cache browser.\n To register the data type and provide it with an id, and icon, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The two null parameters will be handled in the next tutorials  // You can leave them null if you want. This is valid.  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/annotations/",
	"title": "Data annotation algorithms",
	"tags": [],
	"description": "This library provides basic functionality to add annotations to data slot rows.",
	"content": "Data annotations allow JIPipe algorithms and users to assign an unique data set to the data located in a data slot. The standard library contains various algorithms that allow to generate, manipulate, and utilize those annotations.\nWe recommend to use the algorithms in Annotation \u0026gt; Generate while setting up filesystem operations or any other import step to prevent issues in following algorithm steps.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/graph/",
	"title": "Graph",
	"tags": [],
	"description": "A graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph.schema.json\n A graph   nodes:  object   [object Object]      The nodes. Keys are the unique algorithm instance IDs. See graph-node        edges:  object[]       The edges. IDs in the edge definition must be consistent to the IDs in the 'nodes' entry See graph-edge           Example { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/",
	"title": "JSON API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe JSON API that includes the API for creating JSON extensions, but also other data types like a project.\n  Project file specification   JSON extension file specification   JSON objects The JSON API is object-oriented and re-uses different object types in multiple occasions. You will be referred to the specified documentation.\n Algorithm node\nNode in a graph\n  Algorithm type\nDefines a new algorithm\n  Dependency\nProject or extension dependency. Refers to an JIPipe extension.\n  Graph Edge\nEdge in a graph\n  Graph\nA graph\n  Extension\nAn extension that can be put into the ImageJ plugin folder\n  Metadata\nCommonly used metadata type in JIPipe.\n  Point\nA point\n  Project\nAn analysis project\n  Slot definition\nDefines a data slot\n  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/quick-run/",
	"title": "Testing algorithm parameters",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "Many algorithms require plenty of user-defined parameters to create the expected results. Finding those parameters on the other hand can be very time-consuming due to the requirement of repeating all previous and following processing steps.\nJIPipe comes with a feature termed Quick Run that makes it easier to only test a part of an analysis pipeline. You can find the testbench by selecting an algorithm in the algorithm graph and selecting the  Quick Run tab.\nIt will ask for a folder where to store algorithm outputs. For most cases, you can leave the folder as is - but if you expect to generate large amounts of output data, you should select a folder on a drive that can store as much data. Click  Run \u0026amp; open results to create the testbench. JIPipe then will run the pipeline up until the selected algorithm and open a new tab.\nThe Quick Run expects that all relevant algorithms are valid and will tell you if it finds issues. Please fix the issues and click \u0026ldquo;Retry\u0026rdquo;.\n You can also do a Quick Run from an algorithm\u0026rsquo;s right-click context menu.\n If you click {\u0026lt; icon name=\u0026quot;fa-cog\u0026rdquo; size=\u0026quot;medium\u0026rdquo; \u0026gt;}} Run, the results will not be shown. Instead, if enabled, data will just be stored into the Cache\nResult UI After clicking  Run \u0026amp; open results and generating the results, JIPipe will open a new tab in its user interface. It contains a modified version of the result analysis interface that also allows you to change the algorithm parameters and create and load result snapshots of the current algorithm.\nThe user interface is separated into following components:\n The algorithm parameters of the selected algorithm are displayed on the left-hand side. You can change them and create a  New test The results are displayed in the result analysis panel. See the result analysis documentation for more information on how it is used. The testbench allows you to compare multiple parameter sets. On creating a  New test, the results from previous tests are accessible via the drop-down menu. You can also re-label the current parameter set by clicking the  button.  Testing a batch of parameters The testbench currently has not the capabilites to generate a set of parameters. We recommend to use the multi-parameter algorithm feature that was designed to manage parameter sets.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/cache/",
	"title": "Data caching",
	"tags": [],
	"description": "Explains the how JIPipe caches intermediate results and how to access them.",
	"content": "JIPipe has a project-wide cache for generated results. This cache can be accessed by algorithms to prevent repeating previous calculation steps.\nCache items are assigned a unique identifier ( Snapshot) that is based on relevant algorithm parameters and the processing pipeline behind the data generation. You have multiple ways to manage and access the cache. First, in the top tool bar, there is a summary on how many items are currently cached. If items are stored in the cache, you have multiple options to clear the cache.\nIf you select an algorithm, you have access to its  Cache browser that lists all  Snapshots and all stored data, including a string representation, and annotations if available. By selecting a row in the data table below, you can  Show the item\u0026rsquo;s data. The operation depends on the exact data type. ImageJ images for example are opened in ImageJ.\nIf an algorithm data slot has cached data, icons appear next to the slot. Hover the items with your mouse to show a summary. Clicking the items allows you to manage the cache or display the results in a full-window cache browser.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nThe publication is currently in preparation. Please visit this page again later.\n Thanks!\nJIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n  \n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-java-api/parameter-type/",
	"title": "Creating a parameter type",
	"tags": [],
	"description": "Explains how to create an UI for a parameter",
	"content": "JIPipe requires you to register custom parameter types, where they are assigned an unique identifier. This is done to allow future refactoring without breaking a user\u0026rsquo;s project.\nA custom parameter type must be JSON-serializable via the Jackson library. It is associated to an editor UI that is responsible for updating the parameter value from the GUI.\nA parameter type cannot be a generic class. This is due to restrictions in the JVM. We recommend to create a sub-class for a list of a parameter if you require a list of it down the line. The list parameter inherits from the ListParameter class.\n Creating an editor To create an editor UI, you have to inherit from JIPipeParameterEditorUI.\nThe UI class provides access to the JIPipeParameterHolder object and the JIPipeParameterAccess object that encapsulates the getter and setters, as well as additional annotations.\nThere is also access to the SciJava context object.\nPlease be careful to avoid infinite loops between reloading and setting parameters from UI elements.\n Registering a parameter Register the parameter type and its UI in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // You have to provide an unique ID, the parameter class, a method to create a new instance, a method to create a deep copy, and an UI class  registerParameterType(\u0026#34;my-parameter\u0026#34;, MyParameter.class, MyParameter::new, p -\u0026gt; p.clone(), \u0026#34;My parameter\u0026#34;, \u0026#34;A custom parameter type\u0026#34;, MyParameterParameterEditorUI.class); // If you have a hierarchy of parameters, you can register the editor for the whole hierarchy:  registerParameterEditor(MyCollectionBase.class, MyCollectionParameterEditorUI.class); // There is a predefined method to register enum values:  registerEnumParameterType(\u0026#34;my-enum\u0026#34;, MyEnum.class, \u0026#34;My Enum\u0026#34;, \u0026#34;Enum of values\u0026#34;); } }  Do not forget to register all algorithm parameter types. JIPipe will throw an error if it detects a missing parameter registration.\n There is an overload of registerParameterType that takes the matching list directly and automatically generates the ID, name, and description.\n You can set the instance creation function to null if the parameter is default-constructable. You can set the clone function to null if the parameter type can be copied via a copy constructor.\n You can review your parameter UI via Tools \u0026gt; Development \u0026gt; Show all parameter types.\n Making use of the parameter registration You can use the parameter type registry to get a parameter type info. The info provides access to all metadata from the registry.\nJIPipe comes preinstalled with some common Java types (String, numerics, file and folder paths). You can take a look at the Parameters Extension package for all default parameters that are provided by JIPipe.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/json-extension/",
	"title": "Extension",
	"tags": [],
	"description": "An extension that can be put into the ImageJ plugin folder",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: json-extension.schema.json\n An extension that can be put into the ImageJ plugin folder   id:  string       Unique ID of this extension. Should have format  .  :       version:  string       Version of this extension   metadata:  See metadata        General metadata about the extension   algorithms:  object[]       List of added algorithms See algorithm           Example { \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:example-list-tiff\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Example extension\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;An example extension\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;algorithms\u0026#34; : [ { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } ], \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;json-extension\u0026#34; } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Explains functionality that allows ImageJ to run JIPipe algorithms or pipelines.",
	"content": "JIPipe algorithms and pipelines can be executed from within an ImageJ environment. There are two ways JIPipe integrates back into ImageJ:\n You can run a pipeline project from a macro/command You can run JIPipe algorithms from a macro/command if the slot data types are supported by ImageJ  Running a pipeline You can run an JIPipe pipeline via the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe project. It will ask you the project file and the output directory.\nTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe project\u0026quot;, \u0026quot;projectFile=\u0026lt;Project\u0026gt;, outputDirectory=\u0026lt;Directory\u0026gt;, threads=\u0026lt;Threads\u0026gt;\u0026quot;)  There can be issues using the macro recorder depending on which ImageJ algorithms are used. This issue is especially prevalent in ImageJ macro algorithm nodes.\n You can also run JIPipe in headless-mode just like any ImageJ2 algorithm:\n./ImageJ-linux64 --headless --ij2 --run \u0026#34;Run JIPipe project\u0026#34; \u0026#39;projectFile=\u0026#34;\u0026lt;Project\u0026gt;\u0026#34;, outputDirectory=\u0026#34;\u0026lt;Directory\u0026gt;\u0026#34;, threads=\u0026lt;Threads\u0026gt;\u0026#39;  While JIPipe works in Headless-mode, some ImageJ algorithms don\u0026rsquo;t. You will get an error message if an algorithm requires a graphical environment.\n Running a single algorithm JIPipe algorithms can be run from ImageJ macros/commands if the slot data types are compatible with ImageJ. By default, this includes any image data type, result tables, and regions of interest (via ROIManager). If you run the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe algorithm, a dialog with all available algorithms, parameters, and more information is shown.\nA difference to the parameter panel of an algorithm within the graph editor UI is that you have to select the input image.\nOutput data is created according to the slot name. For example if the output slot name is Output, the created image window will also be named Output.\nJust as in a graph, images are converted automatically to the data type specified by the algorithm.\n There may be issues if multiple ROI or result table outputs are generated. JIPipe will merge multiple ROI List data items into one Results Table.\n There can be issues using the macro recorder depending on which ImageJ algorithm is executed. This issue is especially prevalent in ImageJ macro algorithm nodes.\n To run the command via a macro, run:\nrun(\u0026quot;Run JIPipe algorithm\u0026quot;, \u0026quot;algorithmId=\u0026lt;Algorithm\u0026gt;, algorithmParameters=\u0026lt;Parameters\u0026gt;\u0026quot;) The algorithm ID can be looked up via the plugin manager. Algorithm parameters are provided as string in JSON format. The JSON data should have following structure:\n (Optional) An object parameters that contains the algorithm parameters. They are equal to the parameters saved in an JIPipe project file. We recommend to use the Copy command button to obtain the parameters. If you leave out parameters, the default value is assumed. (Optional) An object add-input that contains additional input slot definitions. The entry keys are the slot names. (Optional) An object add-output that contains additional output slot definitions. The entry keys are the slot names. (Optional) An object input. Entry keys correspond to the slot name. The entry value is a string that corresponds to the Window name that contains the data. Only required for image data types, as JIPipe accesses the global ROI manager and global result table.  Use the \u0026ldquo;Copy command\u0026rdquo; button in the \u0026ldquo;Run JIPipe algorithm\u0026rdquo; GUI command to quickly create a valid macro for your parameters.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/plugins/",
	"title": "Managing plugins",
	"tags": [],
	"description": "Explains how to install and manage plugins.",
	"content": "JIPipe has its own plugin (extension) system that is independent of the one provided by ImageJ/SciJava. You can find a list of plugins in Plugins \u0026gt; Manage plugins.\nJIPipe by default supports two types of extensions:\n Java extensions are similar to ImageJ plugins (*.jar) and are the most powerful plugin type. Just like ImageJ plugins, they are located in the plugins directory. JSON plugins are similar to ImageJ macros or scripts, as they are pure text files. Such extensions can be created without programming via the JSON Extension Builder  Some plugins require that dependencies are installed and will notify you if something is wrong. To check if all plugins are in working condition, check if the top right button displays  All plugins valid. Otherwise click the button to show what went wrong and how to solve the issue.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/plots-tables/",
	"title": "Plots and tables",
	"tags": [],
	"description": "This library provides operations to generate and modify tables, as well as creating plots.",
	"content": "The standard library contains algorithms and data types that allows to manipulate tables, and create plots. The table data type is the JIPipe wrapper for the ImageJ results table (see ImageJ integration).\nManipulating tables Table manipulation operations are located in Process \u0026gt; Tables and allow you to add, remove, or replace columns.\nCreating plots Plots can be created via the Analyze \u0026gt; Plot \u0026gt; Plot tables algorithm that processes each incoming result table and produces an automatically generated plot. You can decide which plot type is generated, and how to assign the columns of the input tables to the data series as expected by the plot. Plots are exported automatically as PNG and SVG in the size set up within the algorithm node settings.\nYou can later import the plot back into the JIPipe plot editor that has more options available.\nPlot editor JIPipe comes with a plot editor GUI that allows more refined control over plots than by the standard Plot tables algorithm (for example multiple series). You can either open a plot from results, or create a new plot from scratch via Project \u0026gt; New plot.\nThe settings panel of the plot editor is split into three tabs:\n  Settings contains all general parameters of the plot. It also allows you to change the plot type.  Series contains all data series. A series is a collection of string or number arrays that is used as input for the plot. Depending on the plot type, there can be multiple series (e.g. the line XY plot can display multiple lines)  Data contains a list of data columns that can be assembled to series. You can open the columns in the table editor or import columns from a CSV file. JIPipe also supports generating columns that do not carry any data, but instead generate the requested number of rows.  Table editor While JIPipe prefers opening tables in ImageJ\u0026rsquo;s table view, it contains a table editor that allows you to do basic operations directly from within JIPipe.\nYou can find the operations on the right-hand side. They include some basic operations like modifying rows and columns, and specialized operations for scientific data, such as splitting values by category, quickly integrating the table, and combining columns into a single condition column.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/metadata/",
	"title": "Metadata",
	"tags": [],
	"description": "Commonly used metadata type in JIPipe.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: metadata.schema.json\n Commonly used metadata type in JIPipe.   name:  string       A name   description:  string       A description   authors:  string       Comma-separated list of authors   website:  string       Website of the project   license:  string       Name of the license   citation:  string       Citation for the publication      Example { \u0026#34;name\u0026#34; : \u0026#34;Image property annotations\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used annotations for describing image properties\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/python/",
	"title": "Python integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts.",
	"content": "The standard library contains nodes that allow to run Python scripts using the Jython library. Python scripts have access to all JIPipe and ImageJ APIs that are available at runtime.\nYou can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.     Due to restrictions in the Jython library, Python libraries that are built on a native backend (such as Numpy) will not work.\n As JIPipe builds on the functionality provided by ImageJ. Please refer to the ImageJ documentation to find information on how to expand Jython with additional libraries.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/point/",
	"title": "Point",
	"tags": [],
	"description": "A point",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: point.schema.json\n A point   x:  integer       X coordinate   y:  integer       Y coordinate      Example { \u0026#34;x\u0026#34; : 2900, \u0026#34;y\u0026#34; : 100 } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/standard-library/",
	"title": "Standard library",
	"tags": [],
	"description": "Contains some explanations about the algorithms that are included in the JIPipe standard distribution.",
	"content": "JIPipe comes with a standard library of data types, algorithms, and other functionality that makes it ready to use for most common image analysis projects. The library of course can be extended with plugins.\nPlease take a look at the following standard library components:\n ImageJ integration\nThis library provides integration of ImageJ data types, as well as common ImageJ algorithms.\n  Multi-parameter algorithms\nThis library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.\n  Filesystem algorithms\nThis library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.\n  Data annotation algorithms\nThis library provides basic functionality to add annotations to data slot rows.\n  Plots and tables\nThis library provides operations to generate and modify tables, as well as creating plots.\n  Python integration\nThis library provides nodes that allow to run Python scripts.\n  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation/create-json-extensions/",
	"title": "Extension builder",
	"tags": [],
	"description": "Explains the extension builder tool",
	"content": "JIPipe allows the creation of extensions that contain additional algorithms without the need for writing Java code. We recommend starting from a functional pipeline project and export the whole pipeline or a part of it into a JSON Extension. Alternatively, you can create custom algorithms from scratch within the extension builder.\nIf you want a step-by-step guideline on how to create a custom algorithm, please check out our tutorial.\nExporting from an existing pipeline Within the JIPipe interface, you can find contextual menu items and buttons that allow to generate an exported algorithm.\n To export the whole pipeline as algorithm, select Project \u0026gt; Export as custom algorithm To export a graph compartment, select it and click the Export button at the top-right corner. Then select  As custom algorithm To export a selection of nodes, click the Export button at the top-right corner. JIPipe ensures that connections within the selected nodes are exported as well. To export a single algorithm, click the Export button at the top-right corner. Please note that if the algorithm is a  Group algorithm, the group contents are exported instead of the group iself.  This will open a tab showing a preview of the pipeline. Select Export to extension to copy the custom algorithm into a new or existing extension.\n To open a new extension builder or load a JSON extension, you can use Plugins \u0026gt; New JSON extension ...  The extension builder The extension builder opens three tabs:\n A short introduction A tab that allows you to change the extension settings and metadata A tab that lists all algorithms that are part of the extension  Extension settings All extension metadata can be changed from within this tab. There are only three fields that are mandatory and one where you have to put special care in deciding about the value:\n Unique extension ID is the most important field. It contains a unique identifier that is utilized by JIPipe to figure out project and algorithm dependencies. It must have following format: [Author]:[Id] where [Author] contains information about the author (ideally in Maven-compatible format) and [Id] is the identifier if this extension within the author\u0026rsquo;s group. Version is not used by JIPipe but can be helpful for users to find issues Name is displayed in the plugin manager  You can write anything you want into the other metadata fields or leave them out.\nExtension contents This interface allows you to manage the list of algorithms that are contained within the extension. If you want, you can also create algorithms from scratch (although we do not recommend this as you cannot test pipelines within the extension builder). On selecting an algorithm, you can edit its metadata.\n Algorithm ID is the most important field. It uniquely identifies the algorithm within JIPipe. The ID is not namespaced (meaning that it is independent of the extension ID). We recommend to choose a meaningful name that can be easily expanded for specialized algorithms. Category determines in which menu the algorithm is shown. Please note that if you select DataSource, the algorithm will be placed in a menu based on the output data type. Choosing Internal is not allowed.  You can edit the graph that defines the algorithm\u0026rsquo;s workload by clicking  Edit algorithm. Use this to modify the pipeline to your needs and change parameters. Please note that you cannot test the pipeline.\n We recommend to check if you have some parameters that are invalid or dangerous (e.g. file paths that were copied when exportiong from a project). You algorithms should always have sane defaults.  Exporting parameters By default (this excludes exporting from a  Group algorithm) your algorithm will not have any parameters aside of the default ones (name, description, pass-though, and enabled). The extension builder comes with a powerful editor to reference parameters within the algorithm\u0026rsquo;s graph.\nExported parameters are organized in Groups with each group having a title and optional description. Each group holds a collection of parameter references that can be assigned a custom name and description. Click  Add group to create a new empty group or use the  Auto add algorithm button to import parameters from a node and automatically create groups.\nIn a group, you can use the  Add parameter button to create a reference.\n Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references. If you ignore the warning, JIPipe will just skip them when creating the parameter UI.   The parameter editor UI implements a sub-set of the parameter reference standard to prevent overloading the UI. You always can change the JSON file to control additional properties like a manual order of the parameter items.  "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/project/",
	"title": "Project",
	"tags": [],
	"description": "An analysis project",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: project.schema.json\n An analysis project   jipipe:project-type:  string  , x ∈ { project  (default) }       Used to identify this JSON as JIPipe project   metadata:  See metadata    [object Object]      General information about the project   dependencies:  object[]       Dependencies of this project See dependency        graph:  See graph    [object Object]      Contains the pipeline nodes   compartments:  object   [object Object]      For organization of compartments  compartment-graph:  See graph    [object Object]      Structural graph of compartments          Example { \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;project\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Empty (3 compartments)\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;This template contains three compartments \u0026#39;Preprocessing\u0026#39;, \u0026#39;Analysis\u0026#39;, and \u0026#39;Postprocessing\u0026#39; that are connected to each other.\u0026#34;, \u0026#34;authors\u0026#34; : [ ], \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Standard plots\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used plot types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:plots\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Integrates ImageJ algorithms into JIPipe\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-algorithms\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Compartment management\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types required for graph compartment management\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:compartments\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ integration\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Adds support for commonly used ImageJ data types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-integration\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;additional-metadata\u0026#34; : { \u0026#34;pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe:pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe.ui:project-tabs\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.project.JIPipeProjectTabMetadata\u0026#34;, \u0026#34;data\u0026#34; : { \u0026#34;open-tabs\u0026#34; : [ \u0026#34;singleton:INTRODUCTION\u0026#34;, \u0026#34;singleton:COMPARTMENT_EDITOR\u0026#34;, \u0026#34;graph-compartment:preprocessing\u0026#34;, \u0026#34;graph-compartment:analysis\u0026#34;, \u0026#34;graph-compartment:postprocessing\u0026#34; ], \u0026#34;selected-tab\u0026#34; : null } } }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing-folder-list\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 300 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-folder-list\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;folder-paths\u0026#34; : [ \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5516\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5517\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5518\u0026#34; ], \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Folder list\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;preprocessing-path-to-annotation\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 500 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;path-to-annotation-simple\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;annotation-merge-strategy\u0026#34; : \u0026#34;OverwriteExisting\u0026#34;, \u0026#34;remove-extensions\u0026#34; : true, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;generated-annotation\u0026#34; : \u0026#34;Dataset\u0026#34;, \u0026#34;full-path\u0026#34; : false, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Path to annotation\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 700 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;subfolder\u0026#34; : \u0026#34;in\u0026#34;, \u0026#34;recursive-follows-links\u0026#34; : true, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;*.tif\u0026#34;, \u0026#34;invert\u0026#34; : false } ], \u0026#34;only-filenames\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;recursive\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-import-image\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 900 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-imagej-imgplus-from-file\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;generated-image-type\u0026#34; : \u0026#34;imagej-imgplus\u0026#34;, \u0026#34;title-annotation\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image title\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Import image\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-preprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 1100 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis-gaussian-blur-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-blur-gaussian2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;sigma-y\u0026#34; : -1.0, \u0026#34;sigma-x\u0026#34; : 1.0, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Gaussian blur 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-auto-threshold-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-threshold-auto2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;method\u0026#34; : \u0026#34;Default\u0026#34;, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;dark-background\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Auto threshold 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-distance-transform-watershed-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 650 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-binary-dtwatershed2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Distance transform watershed 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-find-particles-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 850 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-analyze-find-particles2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;min-particle-circularity\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Find particles 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;min-particle-size\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;annotation-type\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image index\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;max-particle-circularity\u0026#34; : 1.0, \u0026#34;split-slices\u0026#34; : true, \u0026#34;exclude-edges\u0026#34; : false, \u0026#34;measurements\u0026#34; : { \u0026#34;values\u0026#34; : [ \u0026#34;Centroid\u0026#34;, \u0026#34;PixelValueMinMax\u0026#34;, \u0026#34;Area\u0026#34; ] }, \u0026#34;max-particle-size\u0026#34; : \u0026#34;Infinity\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-analysis-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 1050 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing-plot-tables\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 550, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;plot-from-table\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;plot-type\u0026#34; : \u0026#34;plot-histogram\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Plot tables\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;plot-parameters/export-height\u0026#34; : 768, \u0026#34;plot-parameters/value-axis-label\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;plot-parameters/bins\u0026#34; : 10, \u0026#34;plot-parameters/export-width\u0026#34; : 1024, \u0026#34;plot-parameters/bin-axis-label\u0026#34; : \u0026#34;Bin\u0026#34;, \u0026#34;plot-parameters/histogram-type\u0026#34; : \u0026#34;Frequency\u0026#34;, \u0026#34;plot-parameters/title\u0026#34; : \u0026#34;Histogram plot\u0026#34;, \u0026#34;column-assignments\u0026#34; : { \u0026#34;parameters\u0026#34; : { \u0026#34;Value\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Values to generate a histogram from. (Numeric column)\u0026#34;, \u0026#34;visibility\u0026#34; : \u0026#34;TransitiveVisible\u0026#34;, \u0026#34;field-class\u0026#34; : \u0026#34;org.hkijena.jipipe.extensions.tables.parameters.TableColumnSourceParameter\u0026#34;, \u0026#34;value\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;PickColumn\u0026#34;, \u0026#34;column-source\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;Equals\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;Area\u0026#34;, \u0026#34;invert\u0026#34; : false }, \u0026#34;generator-source\u0026#34; : { \u0026#34;generator-type\u0026#34; : null, \u0026#34;generated-type\u0026#34; : \u0026#34;NumericColumn\u0026#34; } }, \u0026#34;short-key\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;ui-order\u0026#34; : 0, \u0026#34;field-class-id\u0026#34; : \u0026#34;table-column-source\u0026#34; } } } }, \u0026#34;postprocessing-postprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { }, \u0026#34;output\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 1100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing-plot-tables\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Image\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : true } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Annotated paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-folder-list\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Folder paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Paths\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;ROI\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] }, \u0026#34;compartments\u0026#34; : { \u0026#34;compartment-graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Preprocessing\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Analysis\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 188, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] } } } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/documentation-json-api/slot-definition/",
	"title": "Slot definition",
	"tags": [],
	"description": "Defines a data slot",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: slot-definition.schema.json\n Defines a data slot   slot-data-type:  string       The data type ID of the data stored in this slot   slot-type:  string  , x ∈ { Input  , Output  }       Determines if the slot is an input or an output   inherited-slot:  object      Only valid for output slot. Defines from which slot to inherit the data type. Can be '*' to select the first available slot.   name:  string       Unique slot name   custom-name:  object      User-customizable name. Only displayed in UI.   inheritance-conversions:  object   [object Object]     Only valid for slot inheritance. Applies conversiuons to the inherited type. Must contain map from input data type ID to output data type ID. Conversion is a finite text replacement system.      Example { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inheritance-conversions\u0026#34;: { \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;: \u0026#34;imagej-imgplus-2d-greyscale-8u\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;Output\u0026#34; } "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/",
	"title": "JIPipe",
	"tags": [],
	"description": "",
	"content": "Macro programming for everyone! JIPipe is a graphical batch processing programming language for ImageJ. It comes with an easy-to-use graphical macro editor that requires no programming knowledge. Image processing steps can be added to the user interface and connected to form powerful and complex pipelines that can be easily scaled up and down.\n  Download now   Learn how to use it   Show examples     --   Macro support You already developed custom ImageJ macros? JIPipe allows you to re-use your macros via a Macro node. Copy and paste your code, and add input and output slots.     Algorithm finder You do not know which should be the next processing step? The JIPipe algorithm finder not only lists all compatible processing steps for given data.     Quick run \u0026 caching What are the best algorithm parameters? Find those parameters can be very time-consuming.  JIPipe allows you to easily test multiple algorithm parameters without re-calculating the previous steps. You can go back to an older set of parameters and directly compare the results.     Graph compartments Graph-based programs get quickly confusing? JIPipe allows you to separate the analysis into multiple compartments. You can create as many compartments as you want, connect them, and also export and import them.    Powerful result analysis You can either analyze results directly after processing or load existing results directly into JIPipe. The powerful result analysis tool lets you import data back into ImageJ, or summarize and plot them directly within JIPipe.\n  Table analyzer You want to quickly summarize a table of measurements? JIPipe comes with a tool to summarize and concatenate tables without any external tools. The tool can directly import table data generated by ImageJ.     Plot builder Need to quickly plot a table? JIPipe comes with a powerful plot builder that supports a multitude of different plot types, such as XY plots, bar charts, histograms, and box plots.    Extending JIPipe JIPipe can be extended by programmers and non-programmers via its Java API and its JSON extension API. JSON extensions can be easily created via a graphical user interface and allows you to publish your pipelines as algorithm node. You can also create a hierarchy of custom data annotation types using the built-in editor.\n  Extension builder You want to publish your pipeline? JIPipe comes with a graphical user interface to create plugins. You can add custom algorithms and export them as distributable *.json file. Users just have to put this file into the ImageJ plugins folder.    JIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n  \n "
},
{
	"uri": "https://applied-systems-biology.github.io/jipipe/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]