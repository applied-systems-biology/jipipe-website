[
{
	"uri": "/_header.html",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "/documentation-json-api/graph-node.html",
	"title": "Algorithm node",
	"tags": [],
	"description": "Node in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm-node.schema.json\n Node in a graph   jipipe:slot-configuration:  object   [object Object]      User-defined slots. Might be ignored depending on the algorithm. The keys are the slot names. See slot-definition        jipipe:algorithm-ui-location:  object   [object Object]     Locations of this node within the UI. Optional. The keys depend on the UI implementation. See point        jipipe:algorithm-type:  string       Algorithm type ID   jipipe:algorithm-compartment:  string   DEFAULT      Compartment ID. Only important for the UI.   name:  string       A custom name for this algorithm. Only important for the UI. If null or empty, the UI will default to the algorithm type name.   description:  object       A custom description. Only important for the UI.      Example { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Annotated folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Annotated folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;default-preprocessing\u0026#34; : { \u0026#34;x\u0026#34; : 525, \u0026#34;y\u0026#34; : 100 }, \u0026#34;default-preprocessing{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 }, \u0026#34;default-preprocessing{Horizontal}\u0026#34; : { \u0026#34;x\u0026#34; : 450, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-annotate-by-name\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;default-preprocessing\u0026#34;, \u0026#34;generated-annotation\u0026#34; : \u0026#34;project-sample\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Folders to annotations\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } "
},
{
	"uri": "/documentation/batch-pipelines.html",
	"title": "Batch pipelines",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "JIPipe was designed to always process data in batches, meaning that algorithms always work on multiple data sets at once. This greatly reduces the required work to upscale a processing pipeline from one or few to a large amount of data sets.\nWe will use this pipeline as example:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  In the pipeline, a file is provided as input. Then the file is loaded as image. Finally, the image is processed with a gaussian filter.\nA possible implementation of such a pipeline consists of three algorithms, one for each processing step. An algorithm consumes input and produces output. The exception is the algorithm that loads a user-defined file path into the pipeline.\nJIPipe extends on this concept by allowing input and output slots contain multiple data sets at once. And depending on the algorithm, it either processes each data set individually, or splits, merges, or transforms the list of input data.\nHandling multiple inputs There might be algorithms that require multiple inputs:\nmermaid.initialize({startOnLoad:true}); graph LR; A[Image channel 1] -- B[Merge channels] C[Image channel 2] -- B  The Merge channels algorithm merges the two image channels into one image with two channels. If each data slot only contains one entry, finding image channels that belong to the same data set is trivial.\nFor list-based data slots, like in JIPipe, it is not trivial to find images that should be merged. For example, image1_C1 and image1_C2 should be merged to image1_merged:\nData annotations JIPipe solves this issue by allowing to annotate each data entry (shown as purple entries). Those annotations are in this case automatically extracted and used to group input data. There also can be algorithms that use the annotation information to for example filter or sort data.\nThere are predefined algorithms located within the Annotate menu that for example create annotations based on filenames. JIPipe supports an unlimited amount of annotations that can be attached to data.\nFollowing JIPipe pipeline provides an example of making use of annotations to allow multiple inputs:\n"
},
{
	"uri": "/tutorials/analysis.html",
	"title": "Image analysis pipeline",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as video.   1. First start On starting JIPipe, you will see such a screen: It contains a short introduction, the graph compartment editor, an three pre-defined graph compartments Preprocessing, Analysis, and Postprocessing. As described in the graph compartment documentation, you can ignore graph graph compartments. But in this tutorial we will make use of its capabilities to clearly separate the pipeline into the mentioned tree steps.    2. Graph compartments Here you can see how the data flows between graph compartments. You do not have to do anything here, as this is the default configuration. Data flows from Preprocessing to Analysis, and finally to Postprocessing.  You can ignore the graph compartments and of course define your own data flow. Graph compartments are very flexible. Just take a look at the documentation.    3. Preprocessing In this tutorial, the preprocessing step should consist of algorithms that load and organize data for the following processes. To switch to the graph editor for the preprocessing step, just click the Preprocessing tab. You will find an empty graph aside of the Preprocessing output node. We will utilize this node in a later step to pass preprocessed data to other steps.  The graph is stored project-wide. You can just close all graph editors that you do not need for the current task. You can re-open them via the graph compartment editor. If you closed it, you can re-open it via the Compartment menu in the project menu bar.    4. Adding a data source The most common way how data is provided is to load them from files or folders. JIPipe comes preinstalled with data-types and algorithms that handle filesystem operations. The tutorial data is supplied as set of folders that contain the input images as TIFF files in a sub-directory.We begin by adding a data source that supplies a list of folders. You can find it in Add data \u0026gt; Folder \u0026gt; Folder list. After selecting the item, it will appear in the graph.  You can also drag folders and/or files directly into the graph editor area. Corresponding file data source nodes are then created. For this example, you could just drag the input data folders directly into the graph.   You do not have to navigate via the menu. You can also type the algorithm name or some keywords into the bar that reads Search ....    5. Including the input folders Select the newly created algorithm node by clicking it. The panel on the right-hand side will update and allow you to change the parameters of the selected algorithm node. Click the  Add button and select the input folders.  You can save the current project at any time and re-load it later. If you save it in a parent directory relative to where your data is located, JIPipe automatically saves all paths relative to the project file. This means you can just move all your data, including the project to other machines or hard drive partitions without breaking anything.    6. Annotating data JIPipe is designed as batch processing tool, meaning that it can be always scaled from small test data up to large data sets. It can be helpful for you and some algorithms to know which data belongs together. JIPipe introduces the concept of data annotations that assign data to an unique data set and are passed through the pipeline. You can find more about this in the documentation about how JIPipe processes data. In this step we add the data annotation directly at the beginning by attaching the input folder name to each folder that was passed into the pipeline. This is done via the Annotations \u0026gt; Generate \u0026gt; Path to annotation algorithm. Just add this algorithm into the graph. For more advanced projects there are plenty of other sources for annotations, like importing them from tables, or extracting and modifying annotations.   7. Connecting slots The input folders are converted into a format understandable by JIPipe by the Folder list algorithm. The output then can be passed to following algorithms like the Folders to annotations algorithm we added in the last step. To make a connection click the  or  button and select the available data slot. You can see that a connection between the two data slots was created. This list is always sorted from the closest to the farthest away slot.  You can also use your mouse to drag a connection between slots.    8. Annotation type Annotations are like columns in a table - only that our table contains complex data types. The Path to annotation algorithm automatically extracts the path's file name (or directory name) and annotates it to the input row. By default, the algorithm creates a column Dataset. If you want you can change it to another meaningful column name. And with more complex projects you will probably have many different columns.   9. Extracting the image file We have now the folders and can extract the input image file from each one of them. You can find an algorithm designed for such purposed in File system \u0026gt; List \u0026gt; List files. Add it to the graph and connect it to the Subfolder name output. This algorithm is not only able to list files, but also filter them directly. In this case, we exactly know that our files are located within a sub-folder in. Please update the Subfolder parameter by setting it to in. The filter uses an expression that allows highly flexible filters. But for this example, we only want to test if the filename contains .tif. To do this, type name CONTAINS \".tif\" into the filter box.  If you have more complicate folder structures, you can apply the \"Navigate to sub-folder\" operation with a distinct algorithm. You can find it in the Filesytem category.   We highly recommend that you get familiar with expressions, as they are present in most filtering or generation nodes. They are easy to learn and write, but also allow extremely powerful operations.    10. Testing if the pipeline is correct (Optional) The Quick Run feature allows you to run the pipeline until the selected algorithm and compare multiple parameter sets. It is a good way to test if the pipeline works so far. To create a quick run right-click the List files node and select  Run \u0026amp; show results.  The quick run will check if the pipeline is valid might show some error. If you think that the pipeline is valid, click  Retry to check the pipeline again. It sometimes does not update for performance reasons.   You can also do a quick-run that just refreshes the Cache.   You can also start a Quick Run from the parameter panel if you select the algorithm.    11. Testing if the pipeline is correct - results (Optional) Navigate to the output if the List files algorithm and check if the file paths are correct. See our Quick Run documentation for more information about the testbench and its features.   12. Importing the images After correctly setting up the files, you can import them as images. You can find various importers for image types in Add data. Our images do not require Bio-Formats, so we choose Add data \u0026gt; Image \u0026gt;Import image. Connect it to the output of List files.  The Import image node does not ensure the exact bit depth and dimensionality of the output image. You can change this via a parameter that allows you to choose the exact image type.    13. Preprocessing output You could continue with the analysis directly from the Import image node. But to showcase the graph compartments feature, we decide to have the imported greyscale image as output for of the Preprocessing compartment. The output of a graph compartment is only interfaced through a special node, in this case Preprocessing output.We first have to define an output slot by clicking the  button. Select Import image, set a name, and click  Add.   14. Connecting the output Finally, connect the output of Import image to the new input slot of Preprocessing output.   15. The analysis Now we are finished with the preprocessing. Switch to the Analysis graph compartment by selecting the tab in the tab bar. You see that it also contains a node called Preprocessing output. This is the same node as in the preprocessing compartment, but it only contains output data this time. We continue the analysis with a Gaussian filter that can be found in Images \u0026gt; Blur \u0026gt; Gaussian blur 2D. Add it to the graph and connect it to the output of Preprocessing output.   16. Finding the particles Add following algorithms to the graph and connect them the the previous output:  Images \u0026gt; Threshold \u0026gt; Auto Threshold 2D Images \u0026gt; Binary \u0026gt; Distance transform watershed 2D Images \u0026gt; Analyze \u0026gt; Find particles 2D   This will create a more or less accurate segmentation of the objects (spores) that are visible in the data. The generated masks are then analyzed to extract ROI and measurements.   17. Analysis output Create multiple analysis output slots via the  button. Export at least the measurements table. In our example, we exported the mask, ROI, and the measurements.  You can hide edges if you want. Just click the  or  and select Hide edge.    18. Postprocessing The postprocessing consists of generating a histogram plot of the spore particle areas. You can find a node that generates plots in Tables \u0026gt; Plot \u0026gt; Plot tables. Connect the measurements to the plotting node and set its plot type to  Histogram plot. You see that the node parameters change. They adapt to the the currently selected plot and expect from you to input from which table column(s) to extract the data from. Either you know the name of the columns, or you can use the testbench to generate output and check it yourself. Some algorithms also write the names of their output columns in their description. The correct column for the measurements is Area. You can also change various plot-specific settings and determine how output images are generated.  The plot node automatically generates SVG and PNG renders in the selected resolution. This is not a definite choice, as JIPipe has its own plot builder that can import generated plots from within the results UI.   Aside from exact matching, plot input columns can be matched via a regular expression or generated. Use the generator by selecting . A generator can be useful if you have no matching column within your data.    19. Running the pipeline To run the pipeline, click the  Run button at the top right corner. This will open a new tab where you can select the output directory. You can also generate a random folder that will be located on your operating system's temporary directory by clicking the button. After setting up the parameters, click  Run now.  JIPipe attempts to prevent the most common errors (such as wrong parameters) and displays a message if something was found. Please follow the instructions of those messages. Depending on the data and algorithms, the behavior might not be forseeable and a crash occurs during the processing. A similar easy-to-understand message is shown on how to proceed or repair the issue.    20. Displaying results After the pipeline was successfully executed, a result analysis interface is shown. It displays the results of all output slots. You can navigate through the results via the tree on the left-hand side. On selecting a row, an interface is displayed below the table that contains various operations to import or open the data.   21. Displaying plots To open the generated plots, navigate to Results \u0026gt; Postprocessing \u0026gt; Plot tables \u0026gt; Output and double-click an entry in the list. Alternatively, you can also select the row and click Open in JIPipe. This will open a new tab with a plot builder tool. Please take a look at the plots and tables documentation for more information how the tool works.   "
},
{
	"uri": "/tutorials/analysis_video.html",
	"title": "Image analysis pipeline (Video)",
	"tags": [],
	"description": "This step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as text tutorial.   "
},
{
	"uri": "/documentation-json-api/algorithm.html",
	"title": "Algorithm type",
	"tags": [],
	"description": "Defines a new algorithm",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm.schema.json\n Defines a new node type   id:  string       Unique algorithm ID   metadata:  See metadata        General algorithm metadata   category:  string   org.hkijena.jipipe:miscellaneous      The category   exported-parameters:  object   [object Object]     List of parameters that will be exported to users of the node   graph:  See graph        This graph is executed when the algorithm is run   menu-path:  string       Optional menu path within the category menu   jipipe:project-type:  string  , x ∈ { graph-wrapper-algorithm  (default) }       Identifies the JSON as algorithm      Example { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;parameter-visibilities\u0026#34; : { \u0026#34;visible-keys\u0026#34; : [ ] }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } "
},
{
	"uri": "/tutorials/extension.html",
	"title": "Creating an extension",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.",
	"content": " 1. Existing pipeline In this tutorial, we will create a custom algorithm extension based on parts of the pipeline created in the other tutorial. Please open the project file for the pipeline and navigate to the Preprocessing tab.    2. Selecting the algorithms Please select the following algorithms (you can either do this by holding the Shift keyboard button and clicking the nodes or dragging a selection around the nodes):  Folder list Path to annotation List files Import image  After selecting the algorithms, right-click a selected node and click Export.  Selecting one or multiple algorithms is only one way to create a custom algorithm. You can also export a whole project compartment (via the Compartments tab) or the whole pipeline (via Project \u0026gt; Export as custom algorithm)     3. Preview This will open a new tab where you can see a preview of the pipeline that will be exported. You see that the connections between the selected algorithms were kept, while two additional nodes were added:  Group input Group output  Those two nodes respectively act as input and output of the whole exported algorithm. Its input and output slots will be accessible to users of your custom algorithm. JIPipe automatically creates matching input and output slots based on the selected algorithms, but you can choose to modify your pipeline in this step. Now click Export to extension and then New extension.  You can always modify custom algorithms within the extension builder. This will be shown in a later step.     4. Extension builder This will open the JIPipe extension builder tool that allows you to package one or multiple custom algorithms into an extension. Such extensions can be just put into the ImageJ plugin directory and will be automatically picked up by JIPipe just like any ImageJ plugin. An extension has a set of metadata that you need to set up. To do this, switch to Extension settings.  You can always find the extension builder in Plugins \u0026gt; New JSON extension ...     5. Extension metadata JIPipe utilizes a unique extension ID to identify an extension. This is the most important setting and should be chosen carefully. The format must follow a specific structure: [Author]:[Extension], where [Author] provides information about the extension author, and [Extension] contains some identifier. We recommend to let the [Author] information follow the Maven naming conventions. All the other metadata can be freely chosen or left out (with the exception of the name). Use the other metadata to add authors (including affiliations), a website, define a license, and cite work your pipeline is depending on. Finally, you can review or modify the extension contents by going to Extension contents.  Any dependency to other JIPipe extensions are automatically stored within any project or extension file. JIPipe uses this information to figure out a valid load order.     6. Extension content Our custom algorithm is already included in the list of extension contents (left-hand side). You only need to provide metadata. The most important setting is the unique algorithm ID that is used by JIPipe to identify your algorithm. Please choose a meaningful string that avoids having duplicate identifiers. Then you can provide a name, category, icon and menu location.  The extension builder will warn you if an algorithm ID already exists (we will show this function later). You can choose to ignore this if a duplicate ID is intentional - this will override an algorithm and replace it by the new one.   Algorithm IDs are not namespaced, meaning that they are independent of the extension ID.     7. Parameters By default, your algorithm does not come with parameters aside of the few default parameters (name, description, pass-through, enable). For your pipelines it can be useful to let users change some parameters. The Exported parameters section gives you full control on which parameters can be changed and how they are organized. First, you need to create a group by clicking the  Add group button. This will create a new section in the final parameter UI. Then you can reference parameters by clicking  Add parameter. You can customize the name and descriptions of any item.  It is always a good idea to check the parameters or maybe apply some corrections to the algorithm. To do this, click  Edit graph  You can just add all parameters of a specific algorithm by clicking Auto add algorithm. Just check if users can properly decipher the function of each parameter.   Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references.     8. Modifying the algorithm The extension builder contains a fully function algorithm graph editor (aside of anything that runs the graph) that allows you to modify an algorithm or create one from scratch. Use the editor to check the parameters of your algorithm. For example, it is a good idea to remove the folders from the Folder list algorithm.    9. Validation and installation Click the  Validate button on the top right corner to check for any issues. This tool will also detect duplicate extension and algorithm IDs. Errors about duplicates can be ignored if they are intentional.  Finally, you can install the extension by clicking  Install. This will open a dialog to save the extension into the ImageJ plugin directory and attempt to load the extension.  We still recommend to restart ImageJ, especially if you are installing duplicate IDs.     10. Using the algorithm You can find your algorithm in the menu, navigation bar, and algorithm finder just like any other algorithm. You can see that the parameters are included according to the settings within the extension builder.  JSON Algorithms can be always converted into  Group nodes that unlink the underlying pipeline from the JSON algorithm definition and allows users to modify them. Just select  Convert to group to apply such conversions.    Group nodes are related to JSON algorithms. If you export a single group node, its contents are exported into an algorithm instead of the node itself.     "
},
{
	"uri": "/documentation/standard-library/imagej-integration.html",
	"title": "ImageJ integration",
	"tags": [],
	"description": "This library provides integration of ImageJ data types, as well as common ImageJ algorithms.",
	"content": "The ImageJ integration library integrates common data types from ImageJ into JIPipe:\n Multi-dimensional images (ImagePlus). The standard output file format are TIFF files. Result tables. They are serialized to CSV files. Region of interest (ROI Manager). JIPipe handles ROI as *.zip files.  The ImageJ data types are marked as accessible from outside JIPipe, meaning that algorithms that only use those types can be executed standalone\nImage data types Various ImageJ algorithms only work on data with a specific color type, or dimensionality. To make it easier for algorithms to specifiy which types are suitable, the JIPipe standard library introduces various image sub-types (e.g. 8-bit greyscale 3D image).\nThe library is set up to automatically convert any image data type into any other image data type. During this conversion, the data types automatically attempt to satisfy their constraints or raise an error. The conversion automatically converts a lower-dimensional image into a higher-dimensional image (e.g. 2D to 3D), but not the other way around.\nThe image data types are organized in the following way:\nmermaid.initialize({startOnLoad:true}); graph LR; ImgPlus[\"Image (nD)\"] -- ImgPlusGreyscale[\"Greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale8U[\"8-bit greyscale image (nD)\"] ImgPlusGreyscale8U -- ImgPlusGreyscaleMask[\"8-bit mask (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale16U[\"16-bit greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale32F[\"32-bit float greyscale image (nD)\"] ImgPlus[\"Image (nD)\"] -- ImgPlusColor[\"Color image (nD)\"] ImgPlusColor -- ImgPlusColor8U[\"8-bit color image (nD)\"] ImgPlusColor -- ImgPlusColorRGB[\"RGB color image (nD)\"]  The graph above shows the structure for non-dimensional (nD) images. This structure is repeated for 2D, 3D, \u0026hellip; 5D images.\nColor space conversions are automatically applied (e.g. from RGB to greyscale). While trivial for specific color types (like RGB color), JIPipe falls back to following color spaces for generic colors (e.g. greyscale image):\n   Color space Fallback colorspace     Greyscale 32-bit float greyscale   Color RGB color    Frequency space image data types The JIPipe standard library contains color types that are intended to hold frequency-space (FFT) data. While the standard library only provides methods to handle 2D FFT, there are 3D, \u0026hellip;, 5D data types available for future extensions.\n We rely on the mechanisms provided by ImageJ. For example, the ImageJ FFT generates a 8-bit greyscale power spectrum image and attaches data to the image instance. JIPipe has no special methods to load and save the FFT data, aside from the image data itself. We recommend to generate FFT data within the pipeline to generate the correct data.  ImageJ algorithms The standard library provides a selection of common ImageJ algorithms as JIPipe algorithm nodes. Those algorithms wrap around the respective ImageJ methods and have the same feature set, aside from some changes that are required to make algorithms usable in a batch-environment like JIPipe.\nYou can find a list of all algorithms via the  Help menu on the top right corner and the item Algorithm compendium.\nMacro node If an algorithm is not available as JIPipe node, you can use the Macro node.\n"
},
{
	"uri": "/documentation/graph-editor.html",
	"title": "Pipeline editor",
	"tags": [],
	"description": "Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.",
	"content": "The graph editor (pipeline editor) allows you to edit the processing steps of a graph compartment. Its user interface is separated into three sections:\n The analysis graph contains the processing steps (also referred as algorithms) The settings panel shows the properties of the currently selected algorithms The toolbar allows you to add more algorithms into the graph, navigate to existing algorithms, change some behavior settings of the graph editor, and create screenshots  Analysis graph The analysis graph contains algorithms that are represented by rectangles. The algorithm graph area will automatically grow depending on where you place the algorithms. Scroll bars will appear if the graph area is larger than the available screen size.\n An alternative to using the scroll bars is to hold the middle mouse button while dragging the your mouse.  Algorithms read data from their input slots and output the results into the output slots. There are some algorithms that do not have input slots - they produce output based on their current parameters. The algorithm user interface has three sections:\n Input slots are located on the top of the algorithm UI. Each slot has a unique name that is displayed below the arrow. The arrow opens a menu that allows you to make/modify connections or change other options specific to the slot. Depending on the algorithm, a + button is created that allows you to add more slots. The drag area allows you to move the algorithm around. Move your  mouse pointer over the area and drag your mouse while holding the 🖱 left mouse button. On clicking the  button, a menu will open that contains some algorithm options. Alternatively you can right-click the drag area to open this menu. Output slots are located on the bottom and allow you to connect your output data to the input of another algorithm.   Any output data is always saved automatically by JIPipe. After generating the final output data, there is no need to connect it to any input.  Slot connections You can connect two slots by clicking the  or  button of a slot and by selecting the source/target slot. Input slots can only receive one connection, while outputs can be distributed to as many inputs as you wish. The selection menu shows all available target slots and its sorted from the nearest to the slot that is furthest away.\nA connection is shows as line between the connected slots. The color of the line indicates if this connection is valid or invalid depending on the data types of the source and target.\n A black line indicates that the data types match exactly. A blue line indicates that the types dont match exactly, but can be converted by JIPipe A red line indicates that the types are incompatible. You will probably get an error message during the calculation.   Hover with your mouse over a slot's name to show information about its data type.  Slot options The slot context menu opened by  or  contain additional entries to managing connections.\n  Label this slot allows you to give the slot a custom name without changing the internal workings of the algorithm (As many algorithms are designed to adress specific slots). On selecting the entry, you can give a custom name that is displayed in cursive. To remove the custom label, label it with an empty text.  Find matching algorithm \u0026hellip; opens a tool that lists all compatible algorithms that can receive the output data as input. Depending on the algorithm, you can remove a slot from within this menu  Algorithm settings The algorithm settings are displayed on the right-hand side and contain all settings of the selected algorithm. There are usually four categories:\n  Parameters contains general parameters, like the name displayed in the drag area, and algorithm-specific parameters like thresholds, the selection of methods, and other parameters.  Slots is an alternative to modifying slots via the algorithm UI. Here, you can also re-order slots.  Annotations is an alternative to modifying slot annotations via the algorithm UI. See above for more info about annotations.  Quick run is a tool to run the analysis only up to the selected algorithm. It allows you to try and compare multiple parameters without creating new nodes. See the testbench documentation for more info.  Toolbar The toolbar contains functions to add new algorithms into the graph, navigate to existing algorithms or search the list of available algorithms, and functions to control the algorithm graph display.\n On the left-hand side you can find a menu containing all available algorithms. On selecting an entry, the corresponding algorithm is added to the graph. The navigator allows you to quickly navigate to an existing algorithm instance or create a new one. Just type one or multiple search terms into the field. On pressing the  arrow down key on your keyboard, the first entry is selected. The view options control how the graph editor behaves and contains some additional utility functions.  Additional tools  and allow you to switch between horizontal and vertial view modes. This does not change the pipeline, but just how it is displayed in the editor. By default, a vertical view is enabled. If you prefer that data flows from left to right, choose the horizontal view mode. automatically aligns all nodes in the algorithm graph according to the algorithm by Sugiyama et. al allows you to change how dragging the middle mouse button changes the current view. is enabled by default and makes it that nodes are automatically aligned on creating connections. This feature does not reorganize the whole graph, but only places the target algorithm to a location that better represents the data flow. crops the graph area to the area taken by the algorithm nodes. Use this tool to find your nodes after scrolling too far away. creates a screenshot of the whole graph compartment that is currently being displayed.  "
},
{
	"uri": "/tutorials.html",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "This section contains video and text tutorials for the most common tasks done with JIPipe.\nTutorial list  Image analysis pipeline\nThis step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Image analysis pipeline (Video)\nThis step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Creating an extension\nThis step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.\n  "
},
{
	"uri": "/documentation/standard-library/macro-node.html",
	"title": "Macro node",
	"tags": [],
	"description": "The macro node allows to run ImageJ macros.",
	"content": "The macro node allows to run existing ImageJ macros or execute algorithms that are not directly available as JIPipe nodes. You will find it in Images \u0026gt; ImageJ Macro.\nInputs and outputs By default, the node has no inputs and outputs. Use to the + button to add them. For example, if you want to process one image and output the processed result, create one input and one output.\nBy default, there are four data types that can be used as input and output:\n Any image data type Results table ROI List Paths  Depending on the data type, JIPipe converts inputs into a format that can be processed by an ImageJ macro. The other way around, JIPipe extracts outputs from via modes that are commonly used in macros.\n Developers can provide their own integrations to add more data types.  Image data As input: The image is opened as ImageJ image window, named according to the slot name. We recommend to use the macro command select(\u0026lt;window name\u0026gt;) to first select the image window before applying the processing.\nAs output: The image is extracted from an image window, named according to the slot name. Use the rename() command to rename outputs accordingly.\nExample (for the node shown above)\n// The input is created as window \u0026#34;Input\u0026#34; selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=2\u0026#34;); // The node expects an image window \u0026#34;Output\u0026#34; rename(\u0026#34;Output\u0026#34;); Results table As input: The table data is opened as the main \u0026ldquo;Results\u0026rdquo; table. We recommend to have only one results table input, as the conversion overwrites the current table.\nAs output: The table data is extracted from the main \u0026ldquo;Results\u0026rdquo; table.\n You should only have one results table input, as only the latest input is used. If you want to merge tables, use JIPipe nodes for this.  ROI data As input: The ROI are added to the ROI manager. Like with the results table data, the existing ROI manager is cleared.\nAs output: The ROI are extracted from the ROI manager.\n You should only have one results ROI List data input, as only the latest input is used.  Path data As input: Paths are defined as string variable, named according to the input slot name. Please note that the slot name must be a valid variable name.\nAs output: A path is extracted from a results table window (row 0, column 0). We do not recommend to extact paths as output, as ImageJ does not have native handling for such data.\n We recommend to only use paths as input. The extraction as output is unpredictable, as ImageJ has not a native way to display this type in a way that can be distinguished from result tables.  Parameters The most important parameters are\n The macro code The list of variables  The Code parameter contains the macro code. You can hide it with Collapse or open the code in a larger editor (in a separate tab).\nVariables The macro node allows you to create parameters that can be directly accessed from within JIPipe. The benefit is that those variables can be exported (custom nodes/group node) for ease of use or applying multiple parameter sets.\nClick the Add parameter button in the Macro parameters category to add a variable/parameter.\nIn the dialog, you have to set following options:\n Select the data type of the parameter The Unique identifier acts both as identifier inside JIPipe and the variable name inside the macro. The Name is displayed in the JIPipe GUI The Description field allows you to provide a documentation displayed at the bottom of the parameter list  Variables inside macros On running the macro node, the final code is assembled by adding variables at the top.\nVariables are assembled as var \u0026lt;Unique identifier\u0026gt; = \u0026lt;Value\u0026gt;. The values are converted as following:\n   JIPipe parameter type ImageJ macro variable type     String String   Byte Integer   Short Integer   Double Double   Float Double   Path String   Boolean Boolean    For example, a Gaussian blur node with a Sigma parameter will generate following code:\n// Code generated from parameters var sigma = 2.0; // Code written in the \u0026#34;Code\u0026#34; parameter selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=\u0026#34; + sigma); rename(\u0026#34;Output\u0026#34;);  Path inputs are converted in a similar way.  "
},
{
	"uri": "/documentation/expressions.html",
	"title": "Expression parameters",
	"tags": [],
	"description": "Explains the expression parameter type language that is often used for filtering or generating numbers.",
	"content": "When using nodes that filter or generate data, you might encounter a parameter type called \u0026ldquo;Expression\u0026rdquo;. This parameter allows to to write simple to complex functions that can test for one or multiple conditions or act as input for a generator node. The basic concept of this expression language is to mix string, boolean, and numeric operations into one simple but powerful language. It allows you for example to first calculate a numeric metric and use it for filtering objects within one line.\nThere are always four components you will interact with:\n Literals like numbers (0.5), strings (\u0026quot;hello world\u0026quot;), and boolean values (TRUE, FALSE) Variables that are supplied from the node itself like x, y, or Area Functions that process literals or variables like MIN(x, 5), STRING_EQUALS(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;). Parameters are separated by commas. Operators that do something with the literals, variables, or function results, like subtraction, concatentation, or conditions  The expression language is interpreted as one line and you cannot write own variables. The result of the one expression is supplied to the node for processing.\nThe user interface of the expression parameter allows you to type the expression via a text field. You can also create new lines if you have longer expressions. They will be all merged automatically. If you are unfamiliar with the expression language, you can click the button to open a tool that lists all available functions and operators. This tool will help you to build expressions and check the syntax.\n To get familiar with expression, use JIPipe's integrated calculator tool (Tools  Development  Calculator). You can play around with any expression you like without breaking something.  Variables Variables are set externally by the node and can contain various useful values. For example, filter nodes will put numbers into the variables. Image generator nodes might put the pixel coordinates into them.\nExample Here the node supplies the variables x and y and expects a number back. You can input a formula that will be automatically applied to ally x and y values:\n(x + y) + x/y + 1  The expression builder shows a list of all variables. This list might be incomplete if variables are generated during the runtime (e.g., extracted from a table).  Operators The expressions understand a wide range of common operators for numeric, string, and boolean data:\n You can add, subtract, divide, \u0026hellip; numbers Strings can be concatenated or checked for if one string contains another All basic boolean operators are available  Example You can combine various operators to do complex filtering. Here the node supplies variables Area and MaxWidth:\n(Area \u0026gt; 1000) AND ((MaxWidth^2 / Area \u0026gt; 0.5)) Functions The expression language comes with a large library of predefined functions that you can use for more complex tasks:\nExample To find files, it can be useful to utilize a Glob-filter that can reliably test for the file extension. Here name is the file name and supplied by the node.\nSTRING_MATCHES_GLOB(name, \u0026quot;*.tif\u0026quot;) AND (\u0026quot;data\u0026quot; IN name) Data types The expression language supports five basic data types: Numbers, strings, arrays, and maps\nNumbers Numbers are any kind of number (integer or floating point). Number literals are read as floating point numbers (double).\nExample: 1, 0.5\nStrings Strings are character sequences (texts). They are defined by putting double quotes around a text. If you want to have a double quote inside your string, escape it via \\. If you want a \\ in your text, escape it with another \\.\nExample: \u0026quot;hello world\u0026quot;, \u0026quot;this text has a \\\u0026quot; quote and \\\\ backslash\u0026quot;\nArrays Arrays are collections of values. They are defined via the ARRAY(...) function. Individual items are access via the @ operator and a numeric index starting from zero.\nExample: ARRAY(1,2,3,4) @ 2 will return 3.\nExample: ARRAY(1,2,3,4) @ ARRAY(0,1) will return an array with 1 and 2\nMaps Maps are collections of values where each value is given a unique name. They are defined via the MAP(...) function that should be provided with 2-item arrays (there is a PAIR(key, value) function for this). You can get an array of all keys via the KEYS() function and can access elements via the @ operator.\nExample: MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3)) @ \u0026quot;b\u0026quot; returns 2\nExample: KEYS(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with a, b, and c\nExample: VALUES(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with 1, 2, and 3\nOperators There are many operators with alternative ways to write them available. There are two kinds of operators:\n Symbolic operators are using symbols like $, \u0026amp; or * Textual operators are written words like AND or CONTAINS  The difference between the operators is that symbolic operators can be written without spaces. For example you can write 5+5 or !x. Textual operators require spaces to be separated. For example you cannot write NOTx. You have to write NOT x.\n   Operator Description Usage     Logical AND Returns TRUE if both operands are TRUE x AND y or x \u0026amp; y   Logical OR Returns TRUE if one of the operands is TRUE x OR y or x | y   Logical XOR Returns TRUE if exactly one operand is TRUE x XOR y   Logical NOT Returns TRUE if input is FALSE and vice versa NOT x or ! x   Numeric division Divides the left by the right operand x / y   Numeric exponent Calculates left to the power of the right operand x ^ y   Numeric subtraction / Array removal Subtracts right from left (Numbers). If the operands are arrays, the right items are removed from the left array x - y   Numeric multiplication Multiplies the two operands x * y   Numeric addition / String concatenation / Array concatentation Adds two numbers. Concatenates if the operands are strings. Merges two arrays x + y   Numeric greater than Returns TRUE if the left operand is greater than the right one x \u0026gt; y   Numeric greater or equal Returns TRUE if the left operand is greater or equal to the right x \u0026gt;= y   Numeric less than Returns TRUE if the left operand is less than the right one x \u0026lt; y   Numeric less or equal Returns TRUE if the left operand is less or equal to the right one x \u0026lt;= y   Numeric / String / Boolean equality Returns TRUE if the operands are equal x == y or x EQUALS y   Numeric / String / Boolean inequality Returns TRUE if the operands are unequal x != y or x UNEQUAL y   Numeric negation This is technically an operator -x   Numeric modulo Calculates the modulo x % y   Contains Returns TRUE if the one string is contained in the other one (both operands are strings), or if an array contains an item, or a map contains a values x IN y or y CONTAINS x   Variable exists Returns TRUE if the a variable with the name exists x EXISTS   Resolve variable Returns the value of the variable with name. Useful for variables that have spaces in their names or special characters. $ x (Alternative function: GET_VARIABLE(x))   Get item in array/map Returns the array item(s) or string characters of the left operands. The right-hand side can be a number (the index starting from 0) or an array of indices. If the left operand is a map, the indices are whatever the map uses as index x @ y or x AT y    Precedence The operators are ordered according to a precedence table. You might need to use brackets (()) to force the order you expect:\nThe higher the number is the more the operator is preferred.\n   1 2 3 4 5 6 7 8 9 10     OR AND NOT           XOR                Subtraction (x - y) Divide (x / y)  Power (x^y) Negate (-x)         Modulo (x % y)            Multiply (x * y)          Greater than or equal (x \u0026gt;= y)            Greater than (x \u0026gt; y)            Less than or equal (x \u0026lt;= y)            Less than (x \u0026lt; y)            Equal (x == y)            Unequal (x != y)             String contains (x IN y)            Addition (x + y)            String contains (x CONTAINS y)             Variable exists (x EXISTS)              Array/Map access (x @ y) Variable resolve ($ x)    Compatible types Not all operators are compatible to all types. See following table for the operator\u0026rsquo;s behavior:\n   Operator Number Boolean String Array Map     AND Error OK Error Error Error   NOT Error OK Error Error Error   OR Error OK Error Error Error   XOR Error OK Error Error Error   Divide (x / y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Multiply (x * y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Modulo (x % y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Subtract (x - y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) OK (both operands are arrays) OK (left operand is map, right operand is array or map)   Addition (x + y) OK OK (TRUE=1, FALSE=0) OK (Conversion to strings, string concatenation) OK (both operands are arrays) OK (both operands are maps)   Equality (x == y) OK OK OK (If types differ, conversion to strings) OK OK   Inequality (x != y) OK OK OK OK OK   Contains (x IN y / x CONTAINS y) Error Error OK OK OK   Less than (x \u0026lt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Less than or equal (x \u0026lt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than (x \u0026gt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than or equal (x \u0026gt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Variable exists (x EXISTS) Works (Converted to string) Works (Converted to string) OK Error Error   Variable resolve ($ x) Works (Converted to string) Works (Converted to string) OK Error Error   Get item in array or map (x @ y) Error Error Error OK OK    "
},
{
	"uri": "/faq.html",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "General Can I make the startup faster? Many JIPipe extensions rely on other ImageJ plugins to work. That is why JIPipe always checks if all necessary ImageJ plugins are available. If you are sure that you have everything installed, you can disable this check at Project \u0026gt; Application settings \u0026gt; General \u0026gt; Extensions. Disable Validate ImageJ dependencies.\nUser interface Does JIPipe have a dark mode? Yes, you can enable it in Project \u0026gt; Application settings \u0026gt; UI \u0026gt; General \u0026gt; Theme. Set the theme to Modern dark and restart JIPipe/ImageJ.\nHow can I make long connections without zooming out? Click the arrow button at the input/output slot. It lists all compatible sources/targets ordered by distance.\nCompartments What are those compartments for? Imagine you have a large complicated pipeline. Most certainly, you could split it into multiple sub-pipelines like \u0026ldquo;preprocessing\u0026rdquo; or \u0026ldquo;segmentation\u0026rdquo;. Compartments allow you to do exactly this.\nWhat is the difference between groups and compartments? If you use compartments, JIPipe is still aware of the whole pipeline. This allows it to run all dependency nodes via Update cache or Quick run. Groups are independent pipelines that are not aware where they are used. You can only extract the final outputs, not intermediate steps.\nData processing What happens if I put multiple inputs into a slot? Because each slot holds a table of data and metadata, those tables are merged row-wise.\n Show example     Data     C1_1   C1_2   C1_3    and    Data     C1_4   C1_5   C1_6    are merged into    Data     C1_1   C1_2   C1_3   C1_4   C1_5   C1_6      Why should I care to add those annotations? Annotations are optional for single data analyses or pipelines without multi-input nodes, but helpful anyways. They will allow you to quickly find out from which data set your data was generated.\nIf you have a multi-input node, you will need annotations, as JIPipe needs to figure out which data from which input belongs together.\nYou will find more information here.\nCan you give me an example of multi-input processing? OK, let\u0026rsquo;s imaginge you have two sets of greyscale images (C1 and C2). You want to merge them as channels into an RGB image.\n   Data     C1_1   C1_2   C1_3       Data     C2_1   C2_2   C2_3    The merge channels node has two inputs (one for each channel) and at some point needs to have a table like this to work on:\n   Data (Slot 1) Data (Slot 2)     C1_1 C2_1   C1_2 C2_2   C1_3 C2_3    The issue is now: JIPipe is not aware that you call the images C1_1, C2_1, [\u0026hellip;] and that C1_1 and C2_1 should go together. That\u0026rsquo;s why have to put annotation columns next to the data that will be used by JIPipe:\n   Data #Dataset     C1_1 D1   C1_2 D2   C1_3 D3       Data #Dataset     C2_1 D1   C2_2 D2   C2_3 D3    JIPipe will look at #Dataset and match the rows together that have the same values.\nWhy do you create annotations with a \u0026lsquo;#\u0026rsquo;? There are two kinds of annotations: Ones that only you care about (e.g. the resolution) and the ones the JIPipe should care about. By default all JIPipe\u0026rsquo;s multi-input nodes are configured to only care about annotation columns that begin with #.\nYou can extensively configure this behavior in the node\u0026rsquo;s properties and also manually define which columns JIPipe should look at.\nWhat happens if a reference column is missing? JIPipe will assume an ANY for such columns.\nLet\u0026rsquo;s create an example: Uploading OMERO images require a dataset Id. But often, you only want to upload all images to just one dataset. Here we have three annotated images and just one unannotated OMERO data set.\n   Data #Dataset     Image1 D1   Image2 D2   Image3 D3       Data     OMERO dataset Id    What will to the OMERO data set happen if JIPipe combines the tables?\n   Data #Dataset     OMERO dataset Id {ANY}    It will assume that the one row matches to any #Dataset.\nThe final table will look like this:\n   Data (Slot 1) Data (Slot 2)     Image1 OMERO dataset Id   Image2 OMERO dataset Id   Image3 OMERO dataset Id    Can I preview what the multi-input processing will do without running the node? Yes, switch to the \u0026ldquo;Data batches\u0026rdquo; tab in the properties panel. It allows you to configure how JIPipe merges data together and previews the results.\nDo not forget to refresh after changing a setting.\nImageJ integration Can I use existing ImageJ macros in JIPipe? Yes, use Images \u0026gt; ImageJ macro. The input slots are opened as image windows and can be addressed from within the macro with selectWindow(). You can also load an example that shows how to use the node.\nCan I use JIPipe from within ImageJ macros? Yes. You can use both pipelines and individual JIPipe algorithms from within ImageJ macros and the GUI.\nWhy are some JIPipe algorithms not availabe from within ImageJ? JIPipe has a very general data model that makes it possible to develop pipelines for processing any kind of data. The communication between JIPipe\u0026rsquo;s data types and ImageJ is handled by adaptors that will handle the \u0026ldquo;translation\u0026rdquo; back \u0026amp; forth. For some of such data types, there is no adaptor. The reason behind this is that ImageJ might not have an equivalent data type or feature.\nPerformance How does JIPipe store its data during the analysis? JIPipe stores all necessary inputs and the outputs of each processing step. This means that any kind of large data set will be loaded into the memory at the same time if you set up an iteration.\nFor example, an Import image step will load all the images and then continue with the next steps.\nI have a very large data set. How can I prevent loading it at the same time? You can run JIPipe projects within other JIPipe projects. This will separate them and into individual runs that are iterated one-by-one. JIPipe comes with nodes to extract specific results from those outputs.\nCreate the analysis for only one data set and export project-wide parameters via its project settings. Those parameters will be later modified and should contain anything you need for the project setup. Save it into a *.jip project.\nThen create a separate project and add the nodes Run JIPipe project and Define JIPipe project parameters. In both nodes, you load the main analysis projects.\nResult analysis Can I open a table in ImageJ instead of JIPipe or vice versa? Yes, and even more: Depending on the data type there are multiple options on displaying data available. Select the data in the result view or cache browser and click the ... button at the bottom. JIPipe will even remember the last setting for you.\nCan I save data by their metadata? Yes, use the node Miscellaneous \u0026gt; Export data. It will export all incoming data into one or multiple folders and generates names based on metadata.\nOMERO I do not want to always put in the credentials into each OMERO node. What can I do? Go to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; OMERO and set your credentials there. Any OMERO node will supplement unset credentials by those settings.\n"
},
{
	"uri": "/documentation-json-api/dependency.html",
	"title": "Dependency",
	"tags": [],
	"description": "Project or extension dependency. Refers to an JIPipe extension.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: dependency.schema.json\n Project or extension dependency. Refers to a JIPipe extension.   metadata:  See metadata         id:  string       Unique ID of this dependency should have format  .  :       version:  string       Version of this dependency      Example { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } "
},
{
	"uri": "/documentation.html",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "This section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work.\nBatch processing JIPipe is a tool to create data processing workflows via a graphical language. A special feature of JIPipe processing is always done in batches, meaning that workflows are always designed to scale for large amounts of data without the need of external scripts or major changes in a pipeline.\nThe JIPipe graphical language is graph-based where nodes represent data processing algorithms and edges represent that data is transferred from an algorithm output to another algorithm\u0026rsquo;s input.\nAn example is the application of a gaussian filter to an image after loading it:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  To design efficient and scalable pipelines yourself, it is a good idea to look into the JIPipe data model.\nGraph compartments A common issue with graphical programming languages is that larger pipelines are hard to navigate. Another issue with such languages is that it is hard to separate functional units for easier readability.\nJIPipe solves both issues with the concept of strongly separated graph components that group a set of algorithms together. Components only can interact via special interface algorithms, making it easier to structure the pipeline.\nPlease take a look at our graph compartment documentation for more information.\nUser interface overview The JIPipe user interface is designed around managing an analysis project. A project contains all information to run an analysis, outside of the input data and can be saved into JSON files. The user interface is separated into three sections:\n The project menu contains all operations for the current project / window. It allows you to open/save projects, access and modify graph compartments, manage plugins, and run the analysis The tab bar allows you to switch between different interfaces associated to the current project. You can close thabs by clicking the x icon. If a tab contains some data that will be lost after closing it, you will have to confirm the action. If no question is asked on closing a tab, you will be able to open it later again without losing data. The current content depends on the selected tab   You can also close a tab by clicking it with the middle mouse button.  Further reading  Batch pipelines\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n  Pipeline editor\nExplains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.\n  Expression parameters\nExplains the expression parameter type language that is often used for filtering or generating numbers.\n  Graph compartments\nExplains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n  Running a pipeline\nExplains how to run a pipeline and navigate through the results.\n  Running a single node\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n  Data caching\nExplains the how JIPipe caches intermediate results and how to access them.\n  ImageJ integration\nExplains functionality that allows ImageJ to run JIPipe algorithms or pipelines.\n  Managing plugins\nExplains how to install and manage plugins.\n  Standard library\nContains some explanations about the algorithms that are included in the JIPipe standard distribution.\n  Extension builder\nExplains the extension builder tool\n  "
},
{
	"uri": "/documentation/standard-library/filesystem.html",
	"title": "Filesystem algorithms",
	"tags": [],
	"description": "This library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.",
	"content": "The JIPipe standard library contains data types and algorithms to apply file system operations. The common use case is to extract the list of input files for the following algorithms.\nThe filesystem library has two basic data types:\n A  File contains a path to a file A  Folder contains a path to a folder A Path contains a path to a file or folder  In the Add data menu you can define one file/folder or a list of files/folders.\n We recommend to create a list of files/folders. This makes it easier to scale your workflow up.   Drag any set of files or folders into the graph editor to create corresponding file/folder data source algorithms.  File/folder manipulation algorithms The standard library comes with various algorithms that apply common operations to input filesystem data. This includes listing the files in a folder, filtering files/folders, or navigating to a subfolder. They are placed in the Filesystem category.\nAutomated relativization File and folder data source algorithms by default store absolute paths. If you save your project in a parent folder where the data is stored, the paths are automatically converted into relative paths that make data transfer between devices easier.\nAnnotation It is helpful to add data annotations to the file data at some point. This allows algorithms and users to assign data rows to an unique data set. See the annotation standard library documentation for more information.\n"
},
{
	"uri": "/documentation/graph-compartment.html",
	"title": "Graph compartments",
	"tags": [],
	"description": "Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.",
	"content": "A common issue with graphical programming languages is that large graphs are hard to navigate. JIPipe solves this issue by separating the pipeline graph into sub-graphs. Each sub-graph has a predetermined output node that is visible to other compartments. Other nodes on the other hand are not visible to other compartments.\nThe difference between compartments and simple node groups is that compartments only communicate with each other via the compartment output node. JIPipe also only allows you to edit a specific compartment, instead of the whole graph. By default, JIPipe creates three compartments: Preprocessing, Analysis, and Postprocessing.\n By default a compartment's output node is not visible in any other compartment. The have to be connected in a similar manner on how algorithms are connected. To do this, use the compartment editor that is described in the following section.   You can ignore the compartment feature if you want. You can delete the default compartments without any issue. Just leave one graph compartment and edit the remaining one.   Compartments behave similar to algorithms. This means you can create a directed acyclic graph of compartments.  Creating and connecting compartments JIPipe comes with an editor that allows to control the graph compartments. This editor is similar to the pipeline editor and allows you to create new compartments, connect them, as well as import or export compartments. Instead of containg algorithms, the editor contains graph compartment nodes that can be connected similar to how algorithms are connected.\nYou can one or multiple compartments in the editor. Click the  Edit button to open the compartment in the pipeline editor.\n You can also double-click a compartment node to open the editor.  "
},
{
	"uri": "/documentation/standard-library/multi-parameter.html",
	"title": "Multi-parameter algorithms",
	"tags": [],
	"description": "This library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.",
	"content": "Most algorithms allow handling of multiple parameters via an additional slot that can be optionally enabled. You can find the setting in an algorithm\u0026rsquo;s settings as Multiple parameters. On selecting the item, a new slot will appear that consumes parameter data.\nTo define parameters, use the algorithms found in Add data \u0026gt; Parameters. There are currently two data source algorithms available:\n Define parameter defines a single set of parameters Define multiple parameters lets you define a table of parameters   Use Process  Merge  Merge slots to merge multiple parameter sets.  Defining parameters Both data sources require you to determine which parameters should be created. To do this, add parameters into the Parameters section (red box).\nFor Define multiple parameters, there is an additional element (blue box) that contains a parameter table. Each row represents a parameter set, while a column represents a parameter type. Columns can be added by adding parameters into the Parameters section.\n You can leave the table empty. In this case, the parameters are extracted from the 'Parameters' section.  Select a table cell to open the parameter editor below the table.\nThere are following buttons available:\n Add row adds a new row with standard parameters Generate row allows you to create new rows where one column is generated by the selected generator Replace cells allows you to replace the selected cells in one column with a set of generated parameters  "
},
{
	"uri": "/documentation-json-api/graph-edge.html",
	"title": "Graph Edge",
	"tags": [],
	"description": "Edge in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph-edge.schema.json\n Edge in a graph   source-node:  string       Algorithm ID of the edge source   target-node:  string       Algorithm ID of the edge target   source-slot:  string       Slot name within the edge source algorithm   target-slot:  string       Slot name within the edge target algorithm      Example { \u0026#34;source-node\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-node\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } "
},
{
	"uri": "/documentation/result-analysis.html",
	"title": "Running a pipeline",
	"tags": [],
	"description": "Explains how to run a pipeline and navigate through the results.",
	"content": "JIPipe stores its results in a user-defined output folder. After clicking  Run (located at the top right corner of a project window) JIPipe will query the output folder from you. You can also generate a random folder that will be located on your operating system\u0026rsquo;s temporary directory by clicking the button.\nAfter confirming the settings by clicking  Run now, JIPipe will start processing the pipeline.\n You can have as many runs as you want. Runs will not execute in parallel, but be scheduled to wait until the current run finishes.   The JIPipe output folder is automatically organized in a standardized way, so JIPipe can open a result folder. You find the \"Open analysis output ...\" button in the \"Project\" menu.  Result analysis After all results are generated, the result analysis UI will be automatically opened. It allows you to navigate through the results, and import them back into ImageJ (if supported by the generated data type).\nThe UI has two main components:\n The slot tree shows a hierarchy of all data slots. It is organized by compartment, then algorithm, and finally data slot. By selecting any of the entries, all data associated to the selection or any n-child is displayed. The output data table lists the stored data of the selected slot(s) as table (if you are unfamiliar why this is, please take a look at the explanation on how JIPipe processes data)  After selecting a set of slots in the slot tree the output data table will update to only display the data of the selected slots. The table has following columns:\n (Optional) Compartment shows in which graph compartment the generating algorithm is located (Optional) Algorithm shows the name of the algorithm that generated the data. Location is the folder name where the data is located relative to the slot directory Data shows a string representation of the data row. The contents vary depending on the slot data type. For example, file system data display their path at this location. Additional columns correspond to the data annotations that were attached by various algorithms  Importing results back into JIPipe/ImageJ/\u0026hellip; On selecting one or multiple rows, additional UI elements are displayed below the table. They contain various actions that can be applied to the output data, such as opening the results directory, importing the data back into ImageJ or JIPipe, or any other operation.\n Double-click a row to execute the default action, which is the one most commonly used.  -- "
},
{
	"uri": "/documentation/standard-library/annotations.html",
	"title": "Data annotation algorithms",
	"tags": [],
	"description": "This library provides basic functionality to add annotations to data slot rows.",
	"content": "Data annotations allow JIPipe algorithms and users to assign an unique data set to the data located in a data slot. The standard library contains various algorithms that allow to generate, manipulate, and utilize those annotations.\nWe recommend to use the algorithms in Annotation \u0026gt; Generate while setting up filesystem operations or any other import step to prevent issues in following algorithm steps.\n"
},
{
	"uri": "/documentation-json-api/graph.html",
	"title": "Graph",
	"tags": [],
	"description": "A graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph.schema.json\n A graph   nodes:  object   [object Object]      The nodes. Keys are the unique algorithm instance IDs. See graph-node        edges:  object[]       The edges. IDs in the edge definition must be consistent to the IDs in the 'nodes' entry See graph-edge           Example { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] } "
},
{
	"uri": "/documentation-json-api.html",
	"title": "JSON API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe JSON API that includes the API for creating JSON extensions, but also other data types like a project.\n  Project file specification   JSON extension file specification   JSON objects The JSON API is object-oriented and re-uses different object types in multiple occasions. You will be referred to the specified documentation.\n Algorithm node\nNode in a graph\n  Algorithm type\nDefines a new algorithm\n  Dependency\nProject or extension dependency. Refers to an JIPipe extension.\n  Graph Edge\nEdge in a graph\n  Graph\nA graph\n  Extension\nAn extension that can be put into the ImageJ plugin folder\n  Metadata\nCommonly used metadata type in JIPipe.\n  Point\nA point\n  Project\nAn analysis project\n  Slot definition\nDefines a data slot\n  "
},
{
	"uri": "/documentation/quick-run.html",
	"title": "Running a single node",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "Many algorithms require plenty of user-defined parameters to create the expected results. Finding those parameters on the other hand can be very time-consuming due to the requirement of repeating all previous and following processing steps.\nJIPipe comes with a feature termed Quick Run that makes it easier to only test a part of an analysis pipeline. You can find the testbench by selecting an algorithm in the algorithm graph and selecting the  Quick Run tab.\nIt will ask for a folder where to store algorithm outputs. For most cases, you can leave the folder as is - but if you expect to generate large amounts of output data, you should select a folder on a drive that can store as much data. Click  Run \u0026amp; open results to create the testbench. JIPipe then will run the pipeline up until the selected algorithm and open a new tab.\n The Quick Run expects that all relevant algorithms are valid and will tell you if it finds issues. Please fix the issues and click \"Retry\".   You can also do a Quick Run from an algorithm's right-click context menu. Here you will also find a related option called \"Update cache\" that just updates the cache of the selected node.  If you click  Run, the results will not be shown. Instead, if enabled, data will just be stored into the Cache\nResult UI After clicking  Run \u0026amp; open results and generating the results, JIPipe will open a new tab in its user interface. It contains a modified version of the result analysis interface that also allows you to change the algorithm parameters and create and load result snapshots of the current algorithm.\nThe user interface is separated into following components:\n The algorithm parameters of the selected algorithm are displayed on the left-hand side. You can change them and create a  New test The results are displayed in the result analysis panel. See the result analysis documentation for more information on how it is used. The testbench allows you to compare multiple parameter sets. On creating a  New test, the results from previous tests are accessible via the drop-down menu. You can also re-label the current parameter set by clicking the  button.  Testing a batch of parameters The testbench currently has not the capabilites to generate a set of parameters. We recommend to use the multi-parameter algorithm feature that was designed to manage parameter sets.\n"
},
{
	"uri": "/documentation/cache.html",
	"title": "Data caching",
	"tags": [],
	"description": "Explains the how JIPipe caches intermediate results and how to access them.",
	"content": "JIPipe has a project-wide cache for generated results. This cache can be accessed by algorithms to prevent repeating previous calculation steps.\nLoad data into the cache To cache data, right click a node and click  Update cache. This will execute a Quick run and store all results into the cache.\nAccessing the cache Cache items are assigned a unique identifier ( Snapshot) that is based on relevant algorithm parameters and the processing pipeline behind the data generation. You have multiple ways to manage and access the cache. First, in the top tool bar, there is a summary on how many items are currently cached. If items are stored in the cache, you have multiple options to clear the cache.\nIf you select an algorithm, you have access to its  Cache browser that lists all  Snapshots and all stored data, including a string representation, and annotations if available. By selecting a row in the data table below, you can  Show the item\u0026rsquo;s data. The operation depends on the exact data type. ImageJ images for example are opened in ImageJ.\nIf an algorithm data slot has cached data, icons appear next to the slot. Hover the items with your mouse to show a summary. Clicking the items allows you to manage the cache or display the results in a full-window cache browser.\nManaging the cache The cache consumes large amounts of memory, depending on the pipeline. Use the button at the top (menu bar) to clean all cached data or remove cached items that are invalid (e.g., because the node parameters were changed).\nYou can also enable the \u0026ldquo;Reduce memory\u0026rdquo; mode (bottom) to store unused data on the hard drive, or explicitly move cached items to the hard disk.\n"
},
{
	"uri": "/citation.html",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nThe publication is currently in preparation. Please visit this page again later.\n Thanks!\nJIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n   \n "
},
{
	"uri": "/documentation-json-api/json-extension.html",
	"title": "Extension",
	"tags": [],
	"description": "An extension that can be put into the ImageJ plugin folder",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: json-extension.schema.json\n An extension that can be put into the ImageJ plugin folder   id:  string       Unique ID of this extension. Should have format  .  :       version:  string       Version of this extension   metadata:  See metadata        General metadata about the extension   algorithms:  object[]       List of added algorithms See algorithm           Example { \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:example-list-tiff\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Example extension\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;An example extension\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;algorithms\u0026#34; : [ { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } ], \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;json-extension\u0026#34; } "
},
{
	"uri": "/documentation/imagej-integration.html",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Explains functionality that allows ImageJ to run JIPipe algorithms or pipelines.",
	"content": "ImageJ to JIPipe JIPipe integrates commonly used data types and popular algorithms from ImageJ. If an algorithm is not available for JIPipe, you can still run them via the Macro node. There is also a Python script node available that behaves similar to the macro node.\nJIPipe to ImageJ JIPipe algorithms and pipelines can be executed from within an ImageJ environment. There are two ways JIPipe integrates back into ImageJ:\n You can run a pipeline project from a macro/command You can run JIPipe algorithms from a macro/command if the slot data types are supported by ImageJ  Running a pipeline You can run an JIPipe pipeline via the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe project. It will ask you the project file and the output directory.\nTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe project\u0026quot;, \u0026quot;projectFile=\u0026lt;Project\u0026gt;, outputDirectory=\u0026lt;Directory\u0026gt;, threads=\u0026lt;Threads\u0026gt;\u0026quot;)  There can be issues using the macro recorder depending on which ImageJ algorithms are used. This issue is especially prevalent in ImageJ macro algorithm nodes.  You can also run JIPipe in headless-mode just like any ImageJ2 algorithm:\n./ImageJ-linux64 --headless --ij2 --run \u0026#34;Run JIPipe project\u0026#34; \u0026#39;projectFile=\u0026#34;\u0026lt;Project\u0026gt;\u0026#34;, outputDirectory=\u0026#34;\u0026lt;Directory\u0026gt;\u0026#34;, threads=\u0026lt;Threads\u0026gt;\u0026#39;  While JIPipe works in Headless-mode, some ImageJ algorithms don't. You will get an error message if an algorithm requires a graphical environment.  Running a single algorithm JIPipe algorithms can be run from ImageJ macros/commands if the slot data types are compatible with ImageJ. By default, this includes any image data type, result tables, and regions of interest (via ROIManager). If you run the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe algorithm, a dialog with all available algorithms, parameters, and more information is shown.\nA difference to the parameter panel of an algorithm within the graph editor UI is that you have to select the input image.\nOutput data is created according to the slot name. For example if the output slot name is Output, the created image window will also be named Output.\n Just as in a graph, images are converted automatically to the data type specified by the algorithm.   There may be issues if multiple ROI or result table outputs are generated. JIPipe will merge multiple ROI List data items into one Results Table.   There can be issues using the macro recorder depending on which ImageJ algorithm is executed. This issue is especially prevalent in ImageJ macro algorithm nodes.  To run the command via a macro, run:\nrun(\u0026quot;Run JIPipe algorithm\u0026quot;, \u0026quot;algorithmId=\u0026lt;Algorithm\u0026gt;, algorithmParameters=\u0026lt;Parameters\u0026gt;\u0026quot;) The algorithm ID can be looked up via the plugin manager. Algorithm parameters are provided as string in JSON format. The JSON data should have following structure:\n (Optional) An object parameters that contains the algorithm parameters. They are equal to the parameters saved in an JIPipe project file. We recommend to use the Copy command button to obtain the parameters. If you leave out parameters, the default value is assumed. (Optional) An object add-input that contains additional input slot definitions. The entry keys are the slot names. (Optional) An object add-output that contains additional output slot definitions. The entry keys are the slot names. (Optional) An object input. Entry keys correspond to the slot name. The entry value is a string that corresponds to the Window name that contains the data. Only required for image data types, as JIPipe accesses the global ROI manager and global result table.   Use the \"Copy command\" button in the \"Run JIPipe algorithm\" GUI command to quickly create a valid macro for your parameters.  "
},
{
	"uri": "/documentation/plugins.html",
	"title": "Managing plugins",
	"tags": [],
	"description": "Explains how to install and manage plugins.",
	"content": "JIPipe has its own plugin (extension) system that is independent of the one provided by ImageJ/SciJava. You can find a list of plugins in Plugins \u0026gt; Manage plugins.\nJIPipe by default supports two types of extensions:\n Java extensions are similar to ImageJ plugins (*.jar) and are the most powerful plugin type. Just like ImageJ plugins, they are located in the plugins directory. JSON plugins are similar to ImageJ macros or scripts, as they are pure text files. Such extensions can be created without programming via the JSON Extension Builder  Some plugins require that dependencies are installed and will notify you if something is wrong. To check if all plugins are in working condition, check if the top right button displays  All plugins valid. Otherwise click the button to show what went wrong and how to solve the issue.\n"
},
{
	"uri": "/documentation/standard-library/plots-tables.html",
	"title": "Plots and tables",
	"tags": [],
	"description": "This library provides operations to generate and modify tables, as well as creating plots.",
	"content": "The standard library contains algorithms and data types that allows to manipulate tables, and create plots. The table data type is the JIPipe wrapper for the ImageJ results table (see ImageJ integration).\nManipulating tables Table manipulation operations are located in Process \u0026gt; Tables and allow you to add, remove, or replace columns.\nCreating plots Plots can be created via the Analyze \u0026gt; Plot \u0026gt; Plot tables algorithm that processes each incoming result table and produces an automatically generated plot. You can decide which plot type is generated, and how to assign the columns of the input tables to the data series as expected by the plot. Plots are exported automatically as PNG and SVG in the size set up within the algorithm node settings.\nYou can later import the plot back into the JIPipe plot editor that has more options available.\nPlot editor JIPipe comes with a plot editor GUI that allows more refined control over plots than by the standard Plot tables algorithm (for example multiple series). You can either open a plot from results, or create a new plot from scratch via Project \u0026gt; New plot.\nThe settings panel of the plot editor is split into three tabs:\n  Settings contains all general parameters of the plot. It also allows you to change the plot type.  Series contains all data series. A series is a collection of string or number arrays that is used as input for the plot. Depending on the plot type, there can be multiple series (e.g. the line XY plot can display multiple lines)  Data contains a list of data columns that can be assembled to series. You can open the columns in the table editor or import columns from a CSV file. JIPipe also supports generating columns that do not carry any data, but instead generate the requested number of rows.  Table editor While JIPipe prefers opening tables in ImageJ\u0026rsquo;s table view, it contains a table editor that allows you to do basic operations directly from within JIPipe.\nYou can find the operations on the right-hand side. They include some basic operations like modifying rows and columns, and specialized operations for scientific data, such as splitting values by category, quickly integrating the table, and combining columns into a single condition column.\n"
},
{
	"uri": "/documentation-json-api/metadata.html",
	"title": "Metadata",
	"tags": [],
	"description": "Commonly used metadata type in JIPipe.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: metadata.schema.json\n Commonly used metadata type in JIPipe.   name:  string       A name   description:  string       A description   authors:  string       Comma-separated list of authors   website:  string       Website of the project   license:  string       Name of the license   citation:  string       Citation for the publication      Example { \u0026#34;name\u0026#34; : \u0026#34;Image property annotations\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used annotations for describing image properties\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; } "
},
{
	"uri": "/documentation/standard-library/python.html",
	"title": "Python integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts.",
	"content": "The standard library contains nodes that allow to run Python scripts using the Jython library. Python scripts have access to all JIPipe and ImageJ APIs that are available at runtime.\nYou can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.     Due to restrictions in the Jython library, Python libraries that are built on a native backend (such as Numpy) will not work.   As JIPipe builds on the functionality provided by ImageJ. Please refer to the ImageJ documentation to find information on how to expand Jython with additional libraries.  "
},
{
	"uri": "/documentation-json-api/point.html",
	"title": "Point",
	"tags": [],
	"description": "A point",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: point.schema.json\n A point   x:  integer       X coordinate   y:  integer       Y coordinate      Example { \u0026#34;x\u0026#34; : 2900, \u0026#34;y\u0026#34; : 100 } "
},
{
	"uri": "/documentation/standard-library.html",
	"title": "Standard library",
	"tags": [],
	"description": "Contains some explanations about the algorithms that are included in the JIPipe standard distribution.",
	"content": "JIPipe comes with a standard library of data types, algorithms, and other functionality that makes it ready to use for most common image analysis projects. The library of course can be extended with plugins.\nPlease take a look at the following standard library components:\n ImageJ integration\nThis library provides integration of ImageJ data types, as well as common ImageJ algorithms.\n  Macro node\nThe macro node allows to run ImageJ macros.\n  Filesystem algorithms\nThis library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.\n  Multi-parameter algorithms\nThis library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.\n  Data annotation algorithms\nThis library provides basic functionality to add annotations to data slot rows.\n  Plots and tables\nThis library provides operations to generate and modify tables, as well as creating plots.\n  Python integration\nThis library provides nodes that allow to run Python scripts.\n  "
},
{
	"uri": "/documentation/create-json-extensions.html",
	"title": "Extension builder",
	"tags": [],
	"description": "Explains the extension builder tool",
	"content": "JIPipe allows the creation of extensions that contain additional algorithms without the need for writing Java code. We recommend starting from a functional pipeline project and export the whole pipeline or a part of it into a JSON Extension. Alternatively, you can create custom algorithms from scratch within the extension builder.\nIf you want a step-by-step guideline on how to create a custom algorithm, please check out our tutorial.\nExporting from an existing pipeline Within the JIPipe interface, you can find contextual menu items and buttons that allow to generate an exported algorithm.\n To export the whole pipeline as algorithm, select Project \u0026gt; Export as custom algorithm To export a graph compartment, select it and click the Export button at the top-right corner. Then select  As custom algorithm To export a selection of nodes, click the Export button at the top-right corner. JIPipe ensures that connections within the selected nodes are exported as well. To export a single algorithm, click the Export button at the top-right corner. Please note that if the algorithm is a  Group algorithm, the group contents are exported instead of the group iself.  This will open a tab showing a preview of the pipeline. Select Export to extension to copy the custom algorithm into a new or existing extension.\n To open a new extension builder or load a JSON extension, you can use Plugins \u0026gt; New JSON extension ...  The extension builder The extension builder opens three tabs:\n A short introduction A tab that allows you to change the extension settings and metadata A tab that lists all algorithms that are part of the extension  Extension settings All extension metadata can be changed from within this tab. There are only three fields that are mandatory and one where you have to put special care in deciding about the value:\n Unique extension ID is the most important field. It contains a unique identifier that is utilized by JIPipe to figure out project and algorithm dependencies. It must have following format: [Author]:[Id] where [Author] contains information about the author (ideally in Maven-compatible format) and [Id] is the identifier if this extension within the author\u0026rsquo;s group. Version is not used by JIPipe but can be helpful for users to find issues Name is displayed in the plugin manager  You can write anything you want into the other metadata fields or leave them out.\nExtension contents This interface allows you to manage the list of algorithms that are contained within the extension. If you want, you can also create algorithms from scratch (although we do not recommend this as you cannot test pipelines within the extension builder). On selecting an algorithm, you can edit its metadata.\n Algorithm ID is the most important field. It uniquely identifies the algorithm within JIPipe. The ID is not namespaced (meaning that it is independent of the extension ID). We recommend to choose a meaningful name that can be easily expanded for specialized algorithms. Category determines in which menu the algorithm is shown. Please note that if you select DataSource, the algorithm will be placed in a menu based on the output data type. Choosing Internal is not allowed.  You can edit the graph that defines the algorithm\u0026rsquo;s workload by clicking  Edit algorithm. Use this to modify the pipeline to your needs and change parameters. Please note that you cannot test the pipeline.\n We recommend to check if you have some parameters that are invalid or dangerous (e.g. file paths that were copied when exportiong from a project). You algorithms should always have sane defaults.  Exporting parameters By default (this excludes exporting from a  Group algorithm) your algorithm will not have any parameters aside of the default ones (name, description, pass-though, and enabled). The extension builder comes with a powerful editor to reference parameters within the algorithm\u0026rsquo;s graph.\nExported parameters are organized in Groups with each group having a title and optional description. Each group holds a collection of parameter references that can be assigned a custom name and description. Click  Add group to create a new empty group or use the  Auto add algorithm button to import parameters from a node and automatically create groups.\nIn a group, you can use the  Add parameter button to create a reference.\n Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references. If you ignore the warning, JIPipe will just skip them when creating the parameter UI.   The parameter editor UI implements a sub-set of the parameter reference standard to prevent overloading the UI. You always can change the JSON file to control additional properties like a manual order of the parameter items.  "
},
{
	"uri": "/documentation-json-api/project.html",
	"title": "Project",
	"tags": [],
	"description": "An analysis project",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: project.schema.json\n An analysis project   jipipe:project-type:  string  , x ∈ { project  (default) }       Used to identify this JSON as JIPipe project   metadata:  See metadata    [object Object]      General information about the project   dependencies:  object[]       Dependencies of this project See dependency        graph:  See graph    [object Object]      Contains the pipeline nodes   compartments:  object   [object Object]      For organization of compartments  compartment-graph:  See graph    [object Object]      Structural graph of compartments          Example { \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;project\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Empty (3 compartments)\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;This template contains three compartments \u0026#39;Preprocessing\u0026#39;, \u0026#39;Analysis\u0026#39;, and \u0026#39;Postprocessing\u0026#39; that are connected to each other.\u0026#34;, \u0026#34;authors\u0026#34; : [ ], \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Standard plots\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used plot types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:plots\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Integrates ImageJ algorithms into JIPipe\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-algorithms\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Compartment management\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types required for graph compartment management\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:compartments\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ integration\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Adds support for commonly used ImageJ data types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-integration\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;additional-metadata\u0026#34; : { \u0026#34;pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe:pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe.ui:project-tabs\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.project.JIPipeProjectTabMetadata\u0026#34;, \u0026#34;data\u0026#34; : { \u0026#34;open-tabs\u0026#34; : [ \u0026#34;singleton:INTRODUCTION\u0026#34;, \u0026#34;singleton:COMPARTMENT_EDITOR\u0026#34;, \u0026#34;graph-compartment:preprocessing\u0026#34;, \u0026#34;graph-compartment:analysis\u0026#34;, \u0026#34;graph-compartment:postprocessing\u0026#34; ], \u0026#34;selected-tab\u0026#34; : null } } }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing-folder-list\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 300 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-folder-list\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;folder-paths\u0026#34; : [ \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5516\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5517\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5518\u0026#34; ], \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Folder list\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;preprocessing-path-to-annotation\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 500 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;path-to-annotation-simple\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;annotation-merge-strategy\u0026#34; : \u0026#34;OverwriteExisting\u0026#34;, \u0026#34;remove-extensions\u0026#34; : true, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;generated-annotation\u0026#34; : \u0026#34;Dataset\u0026#34;, \u0026#34;full-path\u0026#34; : false, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Path to annotation\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 700 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;subfolder\u0026#34; : \u0026#34;in\u0026#34;, \u0026#34;recursive-follows-links\u0026#34; : true, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;*.tif\u0026#34;, \u0026#34;invert\u0026#34; : false } ], \u0026#34;only-filenames\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;recursive\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-import-image\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 900 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-imagej-imgplus-from-file\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;generated-image-type\u0026#34; : \u0026#34;imagej-imgplus\u0026#34;, \u0026#34;title-annotation\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image title\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Import image\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-preprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 1100 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis-gaussian-blur-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-blur-gaussian2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;sigma-y\u0026#34; : -1.0, \u0026#34;sigma-x\u0026#34; : 1.0, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Gaussian blur 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-auto-threshold-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-threshold-auto2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;method\u0026#34; : \u0026#34;Default\u0026#34;, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;dark-background\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Auto threshold 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-distance-transform-watershed-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 650 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-binary-dtwatershed2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Distance transform watershed 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-find-particles-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 850 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-analyze-find-particles2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;min-particle-circularity\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Find particles 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;min-particle-size\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;annotation-type\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image index\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;max-particle-circularity\u0026#34; : 1.0, \u0026#34;split-slices\u0026#34; : true, \u0026#34;exclude-edges\u0026#34; : false, \u0026#34;measurements\u0026#34; : { \u0026#34;values\u0026#34; : [ \u0026#34;Centroid\u0026#34;, \u0026#34;PixelValueMinMax\u0026#34;, \u0026#34;Area\u0026#34; ] }, \u0026#34;max-particle-size\u0026#34; : \u0026#34;Infinity\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-analysis-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 1050 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing-plot-tables\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 550, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;plot-from-table\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;plot-type\u0026#34; : \u0026#34;plot-histogram\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Plot tables\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;plot-parameters/export-height\u0026#34; : 768, \u0026#34;plot-parameters/value-axis-label\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;plot-parameters/bins\u0026#34; : 10, \u0026#34;plot-parameters/export-width\u0026#34; : 1024, \u0026#34;plot-parameters/bin-axis-label\u0026#34; : \u0026#34;Bin\u0026#34;, \u0026#34;plot-parameters/histogram-type\u0026#34; : \u0026#34;Frequency\u0026#34;, \u0026#34;plot-parameters/title\u0026#34; : \u0026#34;Histogram plot\u0026#34;, \u0026#34;column-assignments\u0026#34; : { \u0026#34;parameters\u0026#34; : { \u0026#34;Value\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Values to generate a histogram from. (Numeric column)\u0026#34;, \u0026#34;visibility\u0026#34; : \u0026#34;TransitiveVisible\u0026#34;, \u0026#34;field-class\u0026#34; : \u0026#34;org.hkijena.jipipe.extensions.tables.parameters.TableColumnSourceParameter\u0026#34;, \u0026#34;value\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;PickColumn\u0026#34;, \u0026#34;column-source\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;Equals\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;Area\u0026#34;, \u0026#34;invert\u0026#34; : false }, \u0026#34;generator-source\u0026#34; : { \u0026#34;generator-type\u0026#34; : null, \u0026#34;generated-type\u0026#34; : \u0026#34;NumericColumn\u0026#34; } }, \u0026#34;short-key\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;ui-order\u0026#34; : 0, \u0026#34;field-class-id\u0026#34; : \u0026#34;table-column-source\u0026#34; } } } }, \u0026#34;postprocessing-postprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { }, \u0026#34;output\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 1100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing-plot-tables\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Image\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : true } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Annotated paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-folder-list\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Folder paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Paths\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;ROI\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] }, \u0026#34;compartments\u0026#34; : { \u0026#34;compartment-graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Preprocessing\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Analysis\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 188, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] } } } "
},
{
	"uri": "/documentation-json-api/slot-definition.html",
	"title": "Slot definition",
	"tags": [],
	"description": "Defines a data slot",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: slot-definition.schema.json\n Defines a data slot   slot-data-type:  string       The data type ID of the data stored in this slot   slot-type:  string  , x ∈ { Input  , Output  }       Determines if the slot is an input or an output   inherited-slot:  object      Only valid for output slot. Defines from which slot to inherit the data type. Can be '*' to select the first available slot.   name:  string       Unique slot name   custom-name:  object      User-customizable name. Only displayed in UI.   inheritance-conversions:  object   [object Object]     Only valid for slot inheritance. Applies conversiuons to the inherited type. Must contain map from input data type ID to output data type ID. Conversion is a finite text replacement system.      Example { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inheritance-conversions\u0026#34;: { \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;: \u0026#34;imagej-imgplus-2d-greyscale-8u\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;Output\u0026#34; } "
},
{
	"uri": "/_footer.html",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "JIPipe",
	"tags": [],
	"description": "",
	"content": "Macro programming for everyone!  JIPipe is a graphical batch processing programming language for ImageJ that allows you to create macros without any programming  by just creating a flowchart!   Learn how to use it   Show examples   Do you have a question or require some help?  Please do not hesitate to contact us! You can always contact the JIPipe developers via the community, or via E-Mail. If you find a bug, you can also report it directly on GitHub.    Community   Send E-Mail   Report a bug    JIPipe was developed by Research Group Applied Systems BiologyHead: Prof. Dr. Marc Thilo Figge HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany       "
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]